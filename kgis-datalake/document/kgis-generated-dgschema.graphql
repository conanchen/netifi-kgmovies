# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"An object with an ID"
interface Node {
    "    The id of the thing.    The id: ID! in Thing means that an auto-generated ID by Dgraph will be used to identify things.    "
    id: ID!
}

"ãæºæãä¸ä¸ªç»ç»ï¼ä¾å¦å­¦æ ¡ãéæ¿åºç»ç»ãå¬å¸ãä¿±ä¹é¨ç­,ä¹å¯ç¨äºä¸´æ¶å ä¸ªäººç»æçèå¤©å°ç»ï¼æ¿é´"
interface Organization {
    "    ãé¨é¨ã ç»ç»ä¸è¯¥ç»ç»æä¸ªé¨é¨ä¹é´çå³ç³»ï¼ä¹è¢«æè¿°æç»ç»ï¼åè®¸ä¸åçç½åï¼æ è¯ï¼å¼æ¾æ¶é´ï¼ã ä¾å¦ï¼ä¸å®¶æè¯åºçååºï¼æèæ¯ä¸é´å¸¦åå¡åçé¢ååºã A relationship between an organization and a department of that organization, also described as an organization (allowing different urls, logos, opening hours). For example: a store with a pharmacy, or a bakery with a cafe.    "
    departments(first: Int, offset: Int): [Organization]
    "    ç»ç»å®ä¹çè§è²åç§°,hasPartyRoleName,éå±æ§ PartyRoleName.isPartyRoleNameOf    "
    hasPartyRoleName(filter: PartyRoleNameFilter, first: Int, offset: Int, order: PartyRoleNameOrder): [PartyRoleName]
    "    ãä¸çº§ç»ç»ã subOrganizationçååå±æ§ï¼å³åå«è¿ä¸ªç»ç»çæ´å¤§ç»ç»    "
    parentOrganization(first: Int, offset: Int): [Organization]
    "    ãå­æºæã ä¸¤ä¸ªç»ç»ä¹é´çå³ç³»ãå¶ä¸­ç¬¬äºä¸ªç»ç»ï¼ä¾å¦ä»¥å­å¬å¸çåå­ï¼å±äºç¬¬ä¸ä¸ªç»ç»ã    "
    subOrganizations(first: Int, offset: Int): [Organization]
}

"Party å¢ä½:ä»£è¡¨æè¡å¨è½åçä¸ªäººæç»ç»"
interface Party {
    "    æ¥æçnamespace    "
    hasNamespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    ãæ¥æã ç»ç»æä¸ªäººæ¥æçäº§å éå±æ§ Ownable.ownedByï¼Products owned by the organization or person.    "
    owns(filter: OwnershipFilter, first: Int, offset: Int, order: OwnershipOrder): [Ownership]
}

"ãå¢ä½åé¨å®ä¹çè§è²ã"
interface PartyRole {
    "    ãå¼å§æ¥æã æäºçå¼å§æ¥æåæ¶é´    "
    dateFrom: DateTime
    "    ãç»ææ¥æã æ´»å¨ï¼äºä»¶ï¼ç»ææ¶é´ã The end date and time of the item (in ISO 8601 date format).    "
    dateThrough: DateTime
    "    å¨ç»ç»æ¿æè§è²çä¸ªäºº    "
    person(filter: PersonFilter): Person
    "    ä¸ªäººå¨å¢ä½åæ¿æçè§è²    "
    roleName(filter: PartyRoleNameFilter): PartyRoleName
}

"å¯è¯»ç©"
interface Readable {
    "    ãéè¯»æ¶æ¡ã è®°å½æ¯ä¸ªäººéè¯»æ¬æ¡æ¶æ¯çæ¶é´,éå±æ§: ReadNote.isReadNoteOf    "
    hasReadNotes(filter: ReadNoteFilter, first: Int, offset: Int, order: ReadNoteOrder): [ReadNote]
}

"å¯è´­ç©ï¼å¯ä»¥è´­ä¹°è®¢è´­çäº§åææå¡Productï¼Service"
interface Shoppingable {
    "å¯ä»¥è´­ä¹°è®¢è´­çäº§åææå¡Productï¼Service"
    isShoppingable: Boolean
}

"A Thing with an IDï¼å¨KGISå¹³å°åææåå®¹é½æ¯ä¸è¥¿Thing,ä¹å°±æ¯èµæºResource"
interface Thing {
    "    ãå«åã è¯¥é¡¹çå«åã An alias for the item.    "
    alternateName: String
    "ãæè¿°ã è¯¥é¡¹çä¸ä¸ªç®åæè¿°ã A description of the item."
    description: String
    "    ãæ è¯ç¬¦ã æ è¯ç¬¦ The identifier property represents any kind of identifier for any kind of Thing, such as ISBNs, GTIN codes, UUIDs etc.    "
    identifier: String
    "    ãåç§°ãname    Text    The name of the item.    "
    name: String!
    "    èµæºå¯¹è±¡æå±çnamespaces    "
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
}

type AddCartItemPayload {
    cartitem(filter: CartItemFilter, first: Int, offset: Int, order: CartItemOrder): [CartItem]
    numUids: Int
}

type AddCartPayload {
    cart(filter: CartFilter, first: Int, offset: Int, order: CartOrder): [Cart]
    numUids: Int
}

type AddCheckoutItemPayload {
    checkoutitem(filter: CheckoutItemFilter, first: Int, offset: Int, order: CheckoutItemOrder): [CheckoutItem]
    numUids: Int
}

type AddCheckoutPayload {
    checkout(filter: CheckoutFilter, first: Int, offset: Int, order: CheckoutOrder): [Checkout]
    numUids: Int
}

type AddConversationPayload {
    conversation(filter: ConversationFilter, first: Int, offset: Int, order: ConversationOrder): [Conversation]
    numUids: Int
}

type AddDataCatalogPayload {
    datacatalog(filter: DataCatalogFilter, first: Int, offset: Int, order: DataCatalogOrder): [DataCatalog]
    numUids: Int
}

type AddEmployeeRolePayload {
    employeerole(filter: EmployeeRoleFilter, first: Int, offset: Int, order: EmployeeRoleOrder): [EmployeeRole]
    numUids: Int
}

type AddEntryPointPayload {
    entrypoint(filter: EntryPointFilter, first: Int, offset: Int, order: EntryPointOrder): [EntryPoint]
    numUids: Int
}

type AddFollowerRolePayload {
    followerrole(filter: FollowerRoleFilter, first: Int, offset: Int, order: FollowerRoleOrder): [FollowerRole]
    numUids: Int
}

type AddGeneralOrganizationPayload {
    generalorganization(filter: GeneralOrganizationFilter, first: Int, offset: Int, order: GeneralOrganizationOrder): [GeneralOrganization]
    numUids: Int
}

type AddMemberRolePayload {
    memberrole(filter: MemberRoleFilter, first: Int, offset: Int, order: MemberRoleOrder): [MemberRole]
    numUids: Int
}

type AddMessagePayload {
    message(filter: MessageFilter, first: Int, offset: Int, order: MessageOrder): [Message]
    numUids: Int
}

type AddNamespacePayload {
    namespace(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace]
    numUids: Int
}

type AddOfferPayload {
    numUids: Int
    offer(filter: OfferFilter, first: Int, offset: Int, order: OfferOrder): [Offer]
}

type AddOwnershipPayload {
    numUids: Int
    ownership(filter: OwnershipFilter, first: Int, offset: Int, order: OwnershipOrder): [Ownership]
}

type AddPartyRoleNamePayload {
    numUids: Int
    partyrolename(filter: PartyRoleNameFilter, first: Int, offset: Int, order: PartyRoleNameOrder): [PartyRoleName]
}

type AddPersonPayload {
    numUids: Int
    person(filter: PersonFilter, first: Int, offset: Int, order: PersonOrder): [Person]
}

type AddPoderItemPayload {
    numUids: Int
    poderitem(filter: PoderItemFilter, first: Int, offset: Int, order: PoderItemOrder): [PoderItem]
}

type AddPoderPayload {
    numUids: Int
    poder(filter: PoderFilter, first: Int, offset: Int, order: PoderOrder): [Poder]
}

type AddProductModelPayload {
    numUids: Int
    productmodel(filter: ProductModelFilter, first: Int, offset: Int, order: ProductModelOrder): [ProductModel]
}

type AddProductPayload {
    numUids: Int
    product(filter: ProductFilter, first: Int, offset: Int, order: ProductOrder): [Product]
}

type AddReadNotePayload {
    numUids: Int
    readnote(filter: ReadNoteFilter, first: Int, offset: Int, order: ReadNoteOrder): [ReadNote]
}

type AddReviewPayload {
    numUids: Int
    review(filter: ReviewFilter, first: Int, offset: Int, order: ReviewOrder): [Review]
}

type AddSoftwareApplicationPayload {
    numUids: Int
    softwareapplication(filter: SoftwareApplicationFilter, first: Int, offset: Int, order: SoftwareApplicationOrder): [SoftwareApplication]
}

type AddStorePayload {
    numUids: Int
    store(filter: StoreFilter, first: Int, offset: Int, order: StoreOrder): [Store]
}

type AddUserPayload {
    numUids: Int
    user(filter: UserFilter, first: Int, offset: Int, order: UserOrder): [User]
}

type AddWebhookPayload {
    numUids: Int
    webhook(filter: WebhookFilter, first: Int, offset: Int, order: WebhookOrder): [Webhook]
}

"è´­ç©è½¦"
type Cart implements Node & Thing {
    alternateName: String
    createdAt: DateTime
    description: String
    email: String
    id: ID!
    identifier: String
    items(filter: CartItemFilter, first: Int, offset: Int, order: CartItemOrder): [CartItem!]
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    notes: String
    "    è´­ç©è½¦ææè    "
    owner(filter: UserFilter): User!
    updatedAt: DateTime
}

"è´­ç©è½¦åç©åãæå¡ãä¼æ å¸ç­"
type CartItem implements Node & Thing {
    alternateName: String
    createdAt: DateTime!
    description: String
    id: ID!
    identifier: String
    "    æå±è´­ç©è½¦,    "
    isItemOf(filter: CartFilter): Cart
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    quantity: Int!
    type: CartItemType!
    updatedAt: DateTime!
}

"Checkout:A container for all the information required to checkout items and pay.ç»ç®åï¼åå«éè¦ç»ç®åæ¯ä»çææä¿¡æ¯ï¼ç¨æ¶ãéè´§å°åãåç¥¨è´¦åå¯éå°åãå¤æ³¨è¯´æç­ç»ç®åä¿¡æ¯å®å¤åæå¯ä»¥åå»ºè®¢å"
type Checkout implements Node & Thing {
    alternateName: String
    "    The date and time when the checkout was completed.    "
    completedAt: DateTime
    "    The date and time when the checkout was created.    "
    createdAt: DateTime
    description: String
    "    The email attached to this checkout.    "
    email: String
    id: ID!
    identifier: String
    "    A list of line item objects, each one containing information about an item in the checkout.    "
    items(filter: CheckoutItemFilter, first: Int, offset: Int, order: CheckoutItemOrder): [CheckoutItem]
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    The note associated with the checkout.    "
    note: String
    "    ç»ç®åææè    "
    owner(filter: UserFilter): User!
    "    Whether or not the Checkout is ready and can be completed. Checkouts may have asynchronous operations that can take time to finish. If you want to complete a checkout or ensure all the fields are populated and up to date, polling is required until the value is true.    "
    ready: Boolean
    "    States whether or not the fulfillment requires shipping.    "
    requiresShipping: Boolean
    "    The date and time when the checkout was last updated.    "
    updatedAt: DateTime
}

"A single line item in the checkout, grouped by variant and attributes.ç»ç®ååå®¹é¡¹"
type CheckoutItem implements Node & Thing {
    alternateName: String
    description: String
    id: ID!
    identifier: String
    "    æå±ç»ç®å    "
    isItemOf(filter: CheckoutFilter): Checkout
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    The quantity of the line item.    "
    quantity: Int!
    "    Product/Service variant of the line item.    "
    variant: Shoppingable
}

"ãå¯¹è¯ãç»ç»ä¹é´æç¹å®ä¸»é¢çäººåä¹é´çä¸ä¸ªæå¤ä¸ªæ¶æ¯ã å¯ä»¥ä½¿ç¨isPartOfæhasPartå±æ§å°ä¸ªäººæ¶æ¯é¾æ¥å°ä¼è¯ã One or more messages between organizations or people on a particular topic. Individual messages can be linked to the conversation with isPartOf or hasPart properties."
type Conversation implements Node & Thing {
    "    ãå³äºã äºç©çå³äºä¿¡æ¯ The subject matter of the content.    "
    about(filter: ThingFilter): Thing
    "    ãè´è´£äººã å¯¹CreativeWorkè´ææ³å¾è´£ä»»çç¹å®çäººã Specifies the Person that is legally accountable for the CreativeWork.    "
    accountablePerson(filter: UserFilter): User
    alternateName: String
    "    ãä½èã è¯¥ CreativeWork çåä½è/ä½èã    "
    creator(filter: UserFilter): User
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    "    åç§ hasPartãä½åç»ä»¶ã è¡¨ç¤ºæä¸ªä½åæ¯è¯¥ä½åçä¸é¨å    "
    hasMessages(filter: MessageFilter, first: Int, offset: Int, order: MessageOrder): [Message]
    id: ID!
    identifier: String
    "    ãæå¨æ°æ®éç®å½ãæå¨çæ°æ®éç®å½ A data catalog which contains this dataset.    "
    includedInDataCatalog(filter: DataCatalogFilter): DataCatalog
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    æ¬ä¼è¯Conversationç»ç¬¬ä¸æ¹è½¯ä»¶å¦Githubãé¿éäºä»£ç åå»ºçwebhookï¼ç¬¬ä¸æ¹è½¯ä»¶åæ¬ä¼è¯æ¨éäºä»¶æ¶æ¯    "
    webhook(filter: WebhookFilter, first: Int, offset: Int, order: WebhookOrder): [Webhook]
}

"Canonical URL: http://cnschema.org/DataCatalogãæ°æ®ç®å½ãæ°æ®éçç®å½ A collection of datasets."
type DataCatalog implements Node & Thing {
    alternateName: String
    "    ãä½èã è¯¥ CreativeWork çåä½è/ä½èã    "
    creator(filter: UserFilter): User
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    id: ID!
    identifier: String
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    ãæå¨ç¶æ°æ®éç®å½ãæå¨çç¶æ°æ®éç®å½ A data catalog which contains this dataset.    "
    parentDataCatalog(filter: DataCatalogFilter): DataCatalog
    "    ãåå«å­æ°æ®éç®å½ãåå«å­çæ°æ®éç®å½    "
    subDataCatalogs(filter: DataCatalogFilter, first: Int, offset: Int, order: DataCatalogOrder): [DataCatalog]
}

type DeleteCartItemPayload {
    msg: String
    numUids: Int
}

type DeleteCartPayload {
    msg: String
    numUids: Int
}

type DeleteCheckoutItemPayload {
    msg: String
    numUids: Int
}

type DeleteCheckoutPayload {
    msg: String
    numUids: Int
}

type DeleteConversationPayload {
    msg: String
    numUids: Int
}

type DeleteDataCatalogPayload {
    msg: String
    numUids: Int
}

type DeleteEmployeeRolePayload {
    msg: String
    numUids: Int
}

type DeleteEntryPointPayload {
    msg: String
    numUids: Int
}

type DeleteFollowerRolePayload {
    msg: String
    numUids: Int
}

type DeleteGeneralOrganizationPayload {
    msg: String
    numUids: Int
}

type DeleteMemberRolePayload {
    msg: String
    numUids: Int
}

type DeleteMessagePayload {
    msg: String
    numUids: Int
}

type DeleteNamespacePayload {
    msg: String
    numUids: Int
}

type DeleteNodePayload {
    msg: String
    numUids: Int
}

type DeleteOfferPayload {
    msg: String
    numUids: Int
}

type DeleteOwnershipPayload {
    msg: String
    numUids: Int
}

type DeletePartyRoleNamePayload {
    msg: String
    numUids: Int
}

type DeletePersonPayload {
    msg: String
    numUids: Int
}

type DeletePoderItemPayload {
    msg: String
    numUids: Int
}

type DeletePoderPayload {
    msg: String
    numUids: Int
}

type DeleteProductModelPayload {
    msg: String
    numUids: Int
}

type DeleteProductPayload {
    msg: String
    numUids: Int
}

type DeleteReadNotePayload {
    msg: String
    numUids: Int
}

type DeleteReviewPayload {
    msg: String
    numUids: Int
}

type DeleteSoftwareApplicationPayload {
    msg: String
    numUids: Int
}

type DeleteStorePayload {
    msg: String
    numUids: Int
}

type DeleteThingPayload {
    msg: String
    numUids: Int
}

type DeleteUserPayload {
    msg: String
    numUids: Int
}

type DeleteWebhookPayload {
    msg: String
    numUids: Int
}

"[ãéåè§è²ãOrganizationRoleçå­ç±»ï¼æè¿°éåå³ç³»,ææ¶é´éå¶](http://cnschema.org/EmployeeRole)"
type EmployeeRole implements Node & PartyRole & Thing {
    alternateName: String
    dateFrom: DateTime
    dateThrough: DateTime
    description: String
    id: ID!
    identifier: String
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    ãåå·¥ç¼å·ã    "
    number: String
    person(filter: PersonFilter): Person
    roleName(filter: PartyRoleNameFilter): PartyRoleName
}

"http://cnschema.org/EntryPoint å¥å£ãä¸ä¸ªå¥å£ï¼åå«ä¸äºåºäºwebçåè®® An entry point, within some Web-based protocol."
type EntryPoint implements Node & Thing {
    alternateName: String
    description: String
    id: ID!
    identifier: String
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "ãé¾æ¥æ¨¡çã ä¸ä¸ªURLçæ¨¡çï¼å¯ä»¥å©ç¨åååæ°å½¢æå®æ´çURLã An url template (RFC6570) that will be used to construct the target of the execution of the action."
    urlTemplate: String
}

"[ãç¤¾äº¤å³æ³¨è§è²ãFollowerRole)"
type FollowerRole implements Node & PartyRole & Thing {
    alternateName: String
    dateFrom: DateTime
    dateThrough: DateTime
    description: String
    id: ID!
    identifier: String
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    person(filter: PersonFilter): Person
    roleName(filter: PartyRoleNameFilter): PartyRoleName
    "å³æ³¨è®¾ç½®,å¦å³æ³¨ææ°äº§åä¿¡æ¯"
    settings: String
}

"ãä¸è¬æºæãä¸ä¸ªç»ç»ï¼ä¾å¦å­¦æ ¡ãéæ¿åºç»ç»ãå¬å¸ãä¿±ä¹é¨ç­ An organization such as a school, NGO, corporation, club, etc.ä¹ç¨äºä¸´æ¶å ä¸ªäººç»æçèå¤©å°ç»ï¼æ¿é´http://cnschema.org/Organization"
type GeneralOrganization implements Node & Organization & Party & Thing {
    alternateName: String
    "å¯ä»¥è®¿é®çä¼è¯"
    availableConversations(filter: ConversationFilter, first: Int, offset: Int, order: ConversationOrder): [Conversation]
    " æ¬ç»ç»é»è®¤å¯è®¿é®çä¼è¯ "
    defaultConversation(filter: ConversationFilter): Conversation
    departments(first: Int, offset: Int): [Organization]
    description: String
    hasNamespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    hasPartyRoleName(filter: PartyRoleNameFilter, first: Int, offset: Int, order: PartyRoleNameOrder): [PartyRoleName]
    id: ID!
    identifier: String
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    owns(filter: OwnershipFilter, first: Int, offset: Int, order: OwnershipOrder): [Ownership]
    parentOrganization(first: Int, offset: Int): [Organization]
    subOrganizations(first: Int, offset: Int): [Organization]
}

"[ãä¼åè§è²ãOrganizationRoleçå­ç±»ï¼æè¿°ä¼åå³ç³»,ææ¶é´éå¶](http://cnschema.org/EmployeeRole)"
type MemberRole implements Node & PartyRole & Thing {
    alternateName: String
    dateFrom: DateTime
    dateThrough: DateTime
    description: String
    id: ID!
    identifier: String
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    ãä¼åç¼å·ã    "
    number: String
    person(filter: PersonFilter): Person
    roleName(filter: PartyRoleNameFilter): PartyRoleName
}

"ãæ¶æ¯ãç±åéèåç»ä¸ä¸ªæå¤ä¸ªç»ç»æä¸ªäººçä¿¡æ¯ A single message from a sender to one or more organizations or people."
type Message implements Node & Readable & Thing {
    alternateName: String
    "    ãéè¯»æ¥æã å¦æå­å¨åä¸ªçæ¶ä»¶äººï¼å°±æ¯æ¶æ¯è¢«æ¶ä»¶äººè¯»åçæ¥æ/æ¶é´ã The date/time at which the message has been read by the recipient if a single recipient exists.    "
    dateRead: DateTime
    "    ãæ¥æ¶æ¥æã å¦æå­å¨åä¸ªçæ¶ä»¶äººï¼å°±æ¯æ¶æ¯è¢«æ¶ä»¶äººæ¥æ¶çæ¥æ/æ¶é´ã The date/time the message was received if a single recipient exists.    "
    dateReceived: DateTime
    "    ãåéæ¥æã æ¶æ¯è¢«åéçæ¥æ/æ¶é´ã The date/time at which the message was sent.    "
    dateSent: DateTime
    description: String
    hasReadNotes(filter: ReadNoteFilter, first: Int, offset: Int, order: ReadNoteOrder): [ReadNote]
    "    ãè¯è®ºã è¯è®ºï¼ä¸è¬æ¯ç¨æ·å¯¹CreativeWorkçè¯è®ºã    "
    hasReviews(filter: ReviewFilter, first: Int, offset: Int, order: ReviewOrder): [Review]
    id: ID!
    identifier: String
    "    åç§isPartOfãä»å±äºã æ¯å®çä¸é¨å Indicates an item or CreativeWork that this item, or CreativeWork (in some sense), is part of.    "
    isMessageOf(filter: ConversationFilter, first: Int, offset: Int, order: ConversationOrder): [Conversation]
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    ãæ¥æ¶èã åä¸èçå­å±æ§ã å¨è¡å¨æ¥æ¶ç«¯çåä¸èã A sub property of participant. The participant who is at the receiving end of the action.    "
    recipient(filter: UserFilter, first: Int, offset: Int, order: UserOrder): [User]
    "    ãåéèã åä¸èçå­å±æ§ãä¾å¦é®ä»¶çåéèã A sub property of participant. The participant who is at the sending end of the action.    "
    sender(filter: UserFilter): User!
    "    ãæ¶ä»¶äººã æ¶æ¯çç´æ¥æ¶ä»¶äºº A sub property of recipient. The recipient who was directly sent the message.    "
    toRecipient(filter: UserFilter): User
}

type Mutation {
    addCart(input: [AddCartInput!]!): AddCartPayload
    addCartItem(input: [AddCartItemInput!]!): AddCartItemPayload
    addCheckout(input: [AddCheckoutInput!]!): AddCheckoutPayload
    addCheckoutItem(input: [AddCheckoutItemInput!]!): AddCheckoutItemPayload
    addConversation(input: [AddConversationInput!]!): AddConversationPayload
    addDataCatalog(input: [AddDataCatalogInput!]!): AddDataCatalogPayload
    addEmployeeRole(input: [AddEmployeeRoleInput!]!): AddEmployeeRolePayload
    addEntryPoint(input: [AddEntryPointInput!]!): AddEntryPointPayload
    addFollowerRole(input: [AddFollowerRoleInput!]!): AddFollowerRolePayload
    addGeneralOrganization(input: [AddGeneralOrganizationInput!]!): AddGeneralOrganizationPayload
    addMemberRole(input: [AddMemberRoleInput!]!): AddMemberRolePayload
    addMessage(input: [AddMessageInput!]!): AddMessagePayload
    addNamespace(input: [AddNamespaceInput!]!): AddNamespacePayload
    addOffer(input: [AddOfferInput!]!): AddOfferPayload
    addOwnership(input: [AddOwnershipInput!]!): AddOwnershipPayload
    addPartyRoleName(input: [AddPartyRoleNameInput!]!): AddPartyRoleNamePayload
    addPerson(input: [AddPersonInput!]!): AddPersonPayload
    addPoder(input: [AddPoderInput!]!): AddPoderPayload
    addPoderItem(input: [AddPoderItemInput!]!): AddPoderItemPayload
    addProduct(input: [AddProductInput!]!): AddProductPayload
    addProductModel(input: [AddProductModelInput!]!): AddProductModelPayload
    addReadNote(input: [AddReadNoteInput!]!): AddReadNotePayload
    addReview(input: [AddReviewInput!]!): AddReviewPayload
    addSoftwareApplication(input: [AddSoftwareApplicationInput!]!): AddSoftwareApplicationPayload
    addStore(input: [AddStoreInput!]!): AddStorePayload
    addUser(input: [AddUserInput!]!): AddUserPayload
    addWebhook(input: [AddWebhookInput!]!): AddWebhookPayload
    deleteCart(filter: CartFilter!): DeleteCartPayload
    deleteCartItem(filter: CartItemFilter!): DeleteCartItemPayload
    deleteCheckout(filter: CheckoutFilter!): DeleteCheckoutPayload
    deleteCheckoutItem(filter: CheckoutItemFilter!): DeleteCheckoutItemPayload
    deleteConversation(filter: ConversationFilter!): DeleteConversationPayload
    deleteDataCatalog(filter: DataCatalogFilter!): DeleteDataCatalogPayload
    deleteEmployeeRole(filter: EmployeeRoleFilter!): DeleteEmployeeRolePayload
    deleteEntryPoint(filter: EntryPointFilter!): DeleteEntryPointPayload
    deleteFollowerRole(filter: FollowerRoleFilter!): DeleteFollowerRolePayload
    deleteGeneralOrganization(filter: GeneralOrganizationFilter!): DeleteGeneralOrganizationPayload
    deleteMemberRole(filter: MemberRoleFilter!): DeleteMemberRolePayload
    deleteMessage(filter: MessageFilter!): DeleteMessagePayload
    deleteNamespace(filter: NamespaceFilter!): DeleteNamespacePayload
    deleteNode(filter: NodeFilter!): DeleteNodePayload
    deleteOffer(filter: OfferFilter!): DeleteOfferPayload
    deleteOwnership(filter: OwnershipFilter!): DeleteOwnershipPayload
    deletePartyRoleName(filter: PartyRoleNameFilter!): DeletePartyRoleNamePayload
    deletePerson(filter: PersonFilter!): DeletePersonPayload
    deletePoder(filter: PoderFilter!): DeletePoderPayload
    deletePoderItem(filter: PoderItemFilter!): DeletePoderItemPayload
    deleteProduct(filter: ProductFilter!): DeleteProductPayload
    deleteProductModel(filter: ProductModelFilter!): DeleteProductModelPayload
    deleteReadNote(filter: ReadNoteFilter!): DeleteReadNotePayload
    deleteReview(filter: ReviewFilter!): DeleteReviewPayload
    deleteSoftwareApplication(filter: SoftwareApplicationFilter!): DeleteSoftwareApplicationPayload
    deleteStore(filter: StoreFilter!): DeleteStorePayload
    deleteThing(filter: ThingFilter!): DeleteThingPayload
    deleteUser(filter: UserFilter!): DeleteUserPayload
    deleteWebhook(filter: WebhookFilter!): DeleteWebhookPayload
    updateCart(input: UpdateCartInput!): UpdateCartPayload
    updateCartItem(input: UpdateCartItemInput!): UpdateCartItemPayload
    updateCheckout(input: UpdateCheckoutInput!): UpdateCheckoutPayload
    updateCheckoutItem(input: UpdateCheckoutItemInput!): UpdateCheckoutItemPayload
    updateConversation(input: UpdateConversationInput!): UpdateConversationPayload
    updateDataCatalog(input: UpdateDataCatalogInput!): UpdateDataCatalogPayload
    updateEmployeeRole(input: UpdateEmployeeRoleInput!): UpdateEmployeeRolePayload
    updateEntryPoint(input: UpdateEntryPointInput!): UpdateEntryPointPayload
    updateFollowerRole(input: UpdateFollowerRoleInput!): UpdateFollowerRolePayload
    updateGeneralOrganization(input: UpdateGeneralOrganizationInput!): UpdateGeneralOrganizationPayload
    updateMemberRole(input: UpdateMemberRoleInput!): UpdateMemberRolePayload
    updateMessage(input: UpdateMessageInput!): UpdateMessagePayload
    updateNamespace(input: UpdateNamespaceInput!): UpdateNamespacePayload
    updateOffer(input: UpdateOfferInput!): UpdateOfferPayload
    updateOwnership(input: UpdateOwnershipInput!): UpdateOwnershipPayload
    updatePartyRoleName(input: UpdatePartyRoleNameInput!): UpdatePartyRoleNamePayload
    updatePerson(input: UpdatePersonInput!): UpdatePersonPayload
    updatePoder(input: UpdatePoderInput!): UpdatePoderPayload
    updatePoderItem(input: UpdatePoderItemInput!): UpdatePoderItemPayload
    updateProduct(input: UpdateProductInput!): UpdateProductPayload
    updateProductModel(input: UpdateProductModelInput!): UpdateProductModelPayload
    updateReadNote(input: UpdateReadNoteInput!): UpdateReadNotePayload
    updateReview(input: UpdateReviewInput!): UpdateReviewPayload
    updateSoftwareApplication(input: UpdateSoftwareApplicationInput!): UpdateSoftwareApplicationPayload
    updateStore(input: UpdateStoreInput!): UpdateStorePayload
    updateThing(input: UpdateThingInput!): UpdateThingPayload
    updateUser(input: UpdateUserInput!): UpdateUserPayload
    updateWebhook(input: UpdateWebhookInput!): UpdateWebhookPayload
}

"èµæºå¯¹è±¡æå±çnamespace,æ ¹æ®ä¸å®è§åç±å¹³å°çææéç½®å®ä¹å¦ï¼io.shurui.store001.order, é»è®¤å¼æ¯defaultå¦ææä¸ªè§è²æ¥æinamespaceï¼'io.shurui'çæéï¼åæ¥æ'io.shurui'ä¸ä¸ææå­namespaceçç¸åºæé"
type Namespace implements Node & Thing {
    alternateName: String
    description: String
    id: ID!
    identifier: String
    "    æ¥ænamespaceçç»ç»æç¨æ·    "
    isNamespaceOf: Party
    name: String!
    "    èµæºå¯¹è±¡æå±çnamespace,æ ¹æ®ä¸å®è§åç±å¹³å°çææéç½®å®ä¹å¦ï¼io.shurui.store001.order, é»è®¤å¼æ¯default    å¦ææä¸ªè§è²æ¥æinamespaceï¼'io.shurui'çæéï¼åæ¥æ'io.shurui'ä¸ä¸ææå­namespaceçç¸åºæé    "
    namespace: String
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
}

"ååä¾åº"
type Offer implements Node & Thing {
    alternateName: String
    "    ãä»·æ ¼ææå¼å§æ¥æã    "
    dateFrom: DateTime
    "    ãä»·æ ¼ææç»ææ¥æã    "
    dateThrough: DateTime
    description: String
    id: ID!
    identifier: String
    "    å¯è´­ç©çä¸ä¸ªååä¾åº    "
    itemOffered: Shoppingable
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    ä¾åºååçç»ç»æä¸ªäºº Inverse property: makesOffer.    "
    offeredBy: Party
    "    ååä»·æ ¼The offer price of a product, or of a price component when attached to PriceSpecification and its subtypes.    "
    price: Int
}

"æè¿°äº§åçææèææå±æºæçä¿¡æ¯"
type Ownership implements Node & Thing {
    "    ãè·åæ¥æºã äº§åè·åçæºææ¥æº The organization or person from which the product was acquired.    "
    acquiredFrom: Party
    alternateName: String
    "    ãå¼å§æ¥æã æäºçå¼å§æ¥æåæ¶é´    "
    dateFrom: DateTime
    "    ãç»ææ¥æã æ´»å¨ï¼äºä»¶ï¼ç»ææ¶é´ã The end date and time of the item (in ISO 8601 date format).    "
    dateThrough: DateTime
    description: String
    id: ID!
    identifier: String
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    ãä¸è¥¿ç±»åã æ¥æçä¸è¥¿Thingã    "
    owned(filter: ThingFilter): Thing
    "    ãä¸ªäººæç»ç»ãæ¥æè    "
    owner: Party
}

"ç»ç»å®ä¹çè§è²ï¼ç»ç»åç»ç­¹å®ä¹"
type PartyRoleName implements Node & Thing {
    alternateName: String
    "    ãä½èã è¯¥ CreativeWork çåä½è/ä½èãè·CreativeWorkçAuthorå±æ§ä¸æ ·ã The creator/author of this CreativeWork. This is the same as the Author property for CreativeWork.creator    Organization or Person or CreativeWork or UserReviews    "
    creator(filter: UserFilter): User
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    "    è§è²åç»,å¦åå·¥è§è²ç»ãä¼åè§è²ç»    "
    group: String
    id: ID!
    identifier: String
    "    isPartyRoleNameOf,éå±æ§ Organization.hasPartyRoleName    "
    isRoleNameOf: Organization
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
}

"ä¸ªäºº,å¯è½å¨å¹³å°éæä¸ä¸ªä¸å¯ä¸çç¨æ·è´¦å·User"
type Person implements Node & Party & Thing {
    alternateName: String
    description: String
    "ãå§ã å§ã å¨ç¾å½ï¼æ¯ä¸ä¸ªäººå§åä¸­çæåä¸ä¸ªå­ã Family name. In the U.S., the last name of an Person. This can be used along with givenName instead of the name property."
    familyName: String
    "ãåã åãå¨ç¾å½ï¼æ¯ä¸ä¸ªäººåå­ä¸­çç¬¬ä¸ä¸ªå­ Given name. In the U.S., the first name of a Person. This can be used along with familyName instead of the name property."
    givenName: String
    hasNamespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "æ¬äººææ¥æçç¨æ·è´¦å·ï¼éå±æ§User.isUserOfï¼åèInverse property: isPartOf"
    hasUser(filter: UserFilter): User
    id: ID!
    identifier: String
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    owns(filter: OwnershipFilter, first: Int, offset: Int, order: OwnershipOrder): [Ownership]
    "    ä¸ªäººèº«ä»½è¯ID    "
    personalID: String!
}

"https://schema.org/Poder An poder is a confirmation of a transaction (a receipt), which can contain multiple line items, each represented by an Offer that has been accepted by the customer.å½åä¸ºPoderå³æ¯PurchaseOrderè´­ç©è®¢åçææ,ä¸ºäºåºåæåºåè¯Order"
type Poder implements Node & Thing {
    alternateName: String
    "    acceptedOffer    Offer    The offer(s) -- e.g., product, quantity and price combinations -- included in the poder.    billingAddress    PostalAddress    The billing address for the poder.    broker    Organization  or Person    An entity that arranges for an exchange between a buyer and a seller. In most cases a broker never acquires or releases ownership of a product or service involved in an exchange. If it is not clear whether an entity is a broker, seller, or buyer, the latter two terms are preferred. Supersedes bookingAgent.    "
    broker: Party
    "    confirmationNumber    Text    A number that confirms the given poder or payment has been received.    customer    Organization  or Person    Party placing the poder or paying the invoice.    "
    customer: Party
    description: String
    id: ID!
    identifier: String
    "    discount    Number  or Text    Any discount applied (to an Poder).    discountCode    Text    Code used to redeem a discount.    discountCurrency    Text    The currency of the discount.    Use standard formats: ISO 4217 currency format e.g. \"USD\"; Ticker symbol for cryptocurrencies e.g. \"BTC\"; well known names for Local Exchange Tradings Systems (LETS) and other currency types e.g. \"Ithaca HOUR\".    isGift    Boolean    Was the offer accepted as a gift for someone other than the buyer.    "
    isGift: Boolean
    "    poderedItem    PoderItem  or Product  or Service    The item podered.    "
    items(filter: PoderItemFilter, first: Int, offset: Int, order: PoderItemOrder): [PoderItem]
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    poderDate    DateTime  or DateTime    DateTime poder was placed.    "
    poderDate: DateTime
    "    poderNumber    Text    The identifier of the transaction.    "
    poderNumber: String
    "    poderStatus    PoderStatus    The current status of the poder.    "
    poderStatus: PoderStatus
    "    partOfInvoice    Invoice    The poder is being paid as part of the referenced Invoice.    paymentDueDate    DateTime  or DateTime    The date that payment is due. Supersedes paymentDue.    paymentMethod    PaymentMethod    The name of the credit card or other method of payment for the poder.    paymentMethodId    Text    An identifier for the method of payment used (e.g. the last 4 digits of the credit card).    paymentUrl    URL    The URL for sending a payment.    seller    Organization  or Person    An entity which offers (sells / leases / lends / loans) the services / goods. A seller may also be a provider. Supersedes merchant, vendor.    "
    seller: Organization
}

"https://schema.org/PoderItemAn poder item is a line of an poder. It includes the quantity and shipping details of a bought offer.è´­ç©è®¢ååå®¹é¡¹"
type PoderItem implements Node & Thing {
    alternateName: String
    description: String
    id: ID!
    identifier: String
    "    partOfPoder    Poder    The overall poder the items in this delivery were included in.    "
    isItemOf(filter: PoderFilter): Poder
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    poderItemNumber    Text    The identifier of the poder item.    "
    poderItemNumber: String
    "    poderItemStatus    PoderStatus    The current status of the poder item.    "
    poderItemStatus: PoderStatus
    "    poderQuantity    Number    The number of the item podered. If the property is not set, assume the quantity is one.    "
    poderQuantity: Int
    "    poderedItem    PoderItem  or Product  or Service    "
    poderedItem: Shoppingable
}

"äº§å"
type Product implements Node & Shoppingable & Thing {
    alternateName: String
    description: String
    "    ãåå·ã äº§åçåå·ã    "
    hasModels(filter: ProductModelFilter, first: Int, offset: Int, order: ProductModelOrder): [ProductModel]
    id: ID!
    identifier: String
    isShoppingable: Boolean
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
}

"äº§ååå·"
type ProductModel implements Node & Shoppingable & Thing {
    alternateName: String
    description: String
    id: ID!
    identifier: String
    "    ãäº§åã æå±äº§åã    "
    isModelOf(filter: ProductFilter): Product
    isShoppingable: Boolean
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
}

type Query {
    getCart(id: ID!): Cart
    getCartItem(id: ID!): CartItem
    getCheckout(id: ID!): Checkout
    getCheckoutItem(id: ID!): CheckoutItem
    getConversation(id: ID!): Conversation
    getDataCatalog(id: ID!): DataCatalog
    getEmployeeRole(id: ID!): EmployeeRole
    getEntryPoint(id: ID!): EntryPoint
    getFollowerRole(id: ID!): FollowerRole
    getGeneralOrganization(id: ID!): GeneralOrganization
    getMemberRole(id: ID!): MemberRole
    getMessage(id: ID!): Message
    getNamespace(id: ID!): Namespace
    getNode(id: ID!): Node
    getOffer(id: ID!): Offer
    getOwnership(id: ID!): Ownership
    getPartyRoleName(id: ID!): PartyRoleName
    getPerson(id: ID!): Person
    getPoder(id: ID!): Poder
    getPoderItem(id: ID!): PoderItem
    getProduct(id: ID!): Product
    getProductModel(id: ID!): ProductModel
    getReadNote(id: ID!): ReadNote
    getReview(id: ID!): Review
    getSoftwareApplication(id: ID!): SoftwareApplication
    getStore(id: ID!): Store
    getUser(id: ID, username: String): User
    getWebhook(id: ID!): Webhook
    queryCart(filter: CartFilter, first: Int, offset: Int, order: CartOrder): [Cart]
    queryCartItem(filter: CartItemFilter, first: Int, offset: Int, order: CartItemOrder): [CartItem]
    queryCheckout(filter: CheckoutFilter, first: Int, offset: Int, order: CheckoutOrder): [Checkout]
    queryCheckoutItem(filter: CheckoutItemFilter, first: Int, offset: Int, order: CheckoutItemOrder): [CheckoutItem]
    queryConversation(filter: ConversationFilter, first: Int, offset: Int, order: ConversationOrder): [Conversation]
    queryDataCatalog(filter: DataCatalogFilter, first: Int, offset: Int, order: DataCatalogOrder): [DataCatalog]
    queryEmployeeRole(filter: EmployeeRoleFilter, first: Int, offset: Int, order: EmployeeRoleOrder): [EmployeeRole]
    queryEntryPoint(filter: EntryPointFilter, first: Int, offset: Int, order: EntryPointOrder): [EntryPoint]
    queryFollowerRole(filter: FollowerRoleFilter, first: Int, offset: Int, order: FollowerRoleOrder): [FollowerRole]
    queryGeneralOrganization(filter: GeneralOrganizationFilter, first: Int, offset: Int, order: GeneralOrganizationOrder): [GeneralOrganization]
    queryMemberRole(filter: MemberRoleFilter, first: Int, offset: Int, order: MemberRoleOrder): [MemberRole]
    queryMessage(filter: MessageFilter, first: Int, offset: Int, order: MessageOrder): [Message]
    queryNamespace(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace]
    queryNode(filter: NodeFilter, first: Int, offset: Int): [Node]
    queryOffer(filter: OfferFilter, first: Int, offset: Int, order: OfferOrder): [Offer]
    queryOrganization(first: Int, offset: Int): [Organization]
    queryOwnership(filter: OwnershipFilter, first: Int, offset: Int, order: OwnershipOrder): [Ownership]
    queryParty(first: Int, offset: Int): [Party]
    queryPartyRole(first: Int, offset: Int, order: PartyRoleOrder): [PartyRole]
    queryPartyRoleName(filter: PartyRoleNameFilter, first: Int, offset: Int, order: PartyRoleNameOrder): [PartyRoleName]
    queryPerson(filter: PersonFilter, first: Int, offset: Int, order: PersonOrder): [Person]
    queryPoder(filter: PoderFilter, first: Int, offset: Int, order: PoderOrder): [Poder]
    queryPoderItem(filter: PoderItemFilter, first: Int, offset: Int, order: PoderItemOrder): [PoderItem]
    queryProduct(filter: ProductFilter, first: Int, offset: Int, order: ProductOrder): [Product]
    queryProductModel(filter: ProductModelFilter, first: Int, offset: Int, order: ProductModelOrder): [ProductModel]
    queryReadNote(filter: ReadNoteFilter, first: Int, offset: Int, order: ReadNoteOrder): [ReadNote]
    queryReadable(first: Int, offset: Int): [Readable]
    queryReview(filter: ReviewFilter, first: Int, offset: Int, order: ReviewOrder): [Review]
    queryShoppingable(first: Int, offset: Int): [Shoppingable]
    querySoftwareApplication(filter: SoftwareApplicationFilter, first: Int, offset: Int, order: SoftwareApplicationOrder): [SoftwareApplication]
    queryStore(filter: StoreFilter, first: Int, offset: Int, order: StoreOrder): [Store]
    queryThing(filter: ThingFilter, first: Int, offset: Int, order: ThingOrder): [Thing]
    queryUser(filter: UserFilter, first: Int, offset: Int, order: UserOrder): [User]
    queryWebhook(filter: WebhookFilter, first: Int, offset: Int, order: WebhookOrder): [Webhook]
}

"ãéè¯»æ¶æ¡ã è®°å½æ¯ä¸ªäººéè¯»æ¬æ¡æ¶æ¯çæ¶é´"
type ReadNote implements Node & Thing {
    alternateName: String
    "    ãéè¯»æ¥æã    "
    dateRead: DateTime
    description: String
    id: ID!
    identifier: String
    "    ãéè¯»åå®¹ã éå±æ§: Message.hasReadNotes    "
    isReadNoteOf(first: Int, offset: Int): [Readable]
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    ãè¯»èã åå®¹çéè¯»èã    "
    reader(filter: UserFilter): User
}

"ãè¯è®ºãå¯¹é¡¹ç®çè¯è®º - ä¾å¦å¯¹åå®¢æç« çè¯è®ºã è¯¥è¯è®ºçåå®¹æ¯éè¿textå±æ§è¡¨ç¤ºçï¼å¶ä¸»é¢éè¿aboutï¼ä¸ææCreativeWorkså±äº«çå±æ§æ¥è¡¨è¾¾ A comment on an item - for example, a comment on a blog post. The comment's content is expressed via the text property, and its topic via about, properties shared with all CreativeWorks."
type Review implements Node & Thing {
    alternateName: String
    "    ãä½èã æ­¤åå®¹æè¯åçä½èã    "
    author(filter: UserFilter): User
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã    "
    dateCreated: DateTime
    description: String
    id: ID!
    identifier: String
    "itemReviewed    Thing    The item that is being reviewed/rated."
    itemReviewed(filter: ThingFilter): Thing
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    ratingValue    è¯å The rating for the content.    "
    ratingValue: Int
    "reviewAspect    Text    This Review or Rating is relevant to this part or facet of the itemReviewed."
    reviewAspect: String
    "reviewBody    Text    The actual body of the review."
    reviewBody: String
}

"https://schema.org/SoftwareApplication A software application."
type SoftwareApplication implements Node & Thing {
    alternateName: String
    "    applicationSuite    Text    The name of the application suite to which the application belongs (e.g. Excel belongs to Office).    "
    applicationSuite: String
    description: String
    "    availableOnDevice    Text    Device required to run the application. Used in cases where a specific make/model is required to run the application. Supersedes device.    countriesNotSupported    Text    Countries for which the application is not supported. You can also provide the two-letter ISO 3166-1 alpha-2 country code.    countriesSupported    Text    Countries for which the application is supported. You can also provide the two-letter ISO 3166-1 alpha-2 country code.    downloadUrl    URL    If the file can be downloaded, URL to download the binary.    "
    downloadUrl: String
    "    featureList    Text  or URL    Features or modules provided by this application (and possibly required by other applications).    "
    featureList: String
    id: ID!
    identifier: String
    "    fileSize    Text    Size of the application / package (e.g. 18MB). In the absence of a unit (MB, KB etc.), KB will be assumed.    installUrl    URL    URL at which the app may be installed, if different from the URL of the item.    "
    installUrl: String
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    memoryRequirements    Text  or URL    Minimum memory requirements.    operatingSystem    Text    Operating systems supported (Windows 7, OSX 10.6, Android 1.6).    permissions    Text    Permission(s) required to run the app (for example, a mobile app may require full internet access or may run only on wifi).    processorRequirements    Text    Processor architecture required to run the application (e.g. IA64).    releaseNotes    Text  or URL    Description of what changed in this version.    "
    releaseNotes: String
    "    screenshot    ImageObject  or URL    A link to a screenshot image of the app.    "
    screenshot: String
    "    softwareAddOn    SoftwareApplication    Additional content for a software application.    softwareHelp    CreativeWork    Software application help.    softwareRequirements    Text  or URL    Component dependency requirements for application. This includes runtime environments and shared libraries that are not included in the application distribution package, but required to run the application (Examples: DirectX, Java or .NET runtime). Supersedes requirements.    softwareVersion    Text    Version of the software instance.    storageRequirements    Text  or URL    Storage requirements (free space required).    supportingData    DataFeed    Supporting data for a SoftwareApplication.    "
    softwareVersion: String
}

"é¶å®åºéº"
type Store implements Node & Organization & Party & Thing {
    alternateName: String
    "    ãåå»ºäººã è¯¥ç©ä½çåä½è/ä½èã    "
    creator(filter: UserFilter): User
    "    ãåå»ºæ¥æã    "
    dateCreated: DateTime
    "    ãæ´æ°æ¥æã    "
    dateModified: DateTime
    departments(first: Int, offset: Int): [Organization]
    description: String
    "    ãéåã ç»ç»çéå.å¨ç»ç»æ¿æè§è²çä¸ªäººææ¶é´éå¶    "
    employees(filter: EmployeeRoleFilter, first: Int, offset: Int, order: EmployeeRoleOrder): [EmployeeRole]
    "    ãå³æ³¨ç»ç»çäººã ç¤¾äº¤ç½ç»ä¸æ¬ç»ç»è¢«å«äººå³æ³¨    "
    followers(filter: FollowerRoleFilter, first: Int, offset: Int, order: FollowerRoleOrder): [FollowerRole]
    hasNamespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    hasPartyRoleName(filter: PartyRoleNameFilter, first: Int, offset: Int, order: PartyRoleNameOrder): [PartyRoleName]
    id: ID!
    identifier: String
    "    ãä¼åã ç»ç»æé¡¹ç®çæå,å¨ç»ç»æ¿æè§è²çä¸ªäººææ¶é´éå¶    "
    members(filter: MemberRoleFilter, first: Int, offset: Int, order: MemberRoleOrder): [MemberRole]
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    owns(filter: OwnershipFilter, first: Int, offset: Int, order: OwnershipOrder): [Ownership]
    parentOrganization(first: Int, offset: Int): [Organization]
    subOrganizations(first: Int, offset: Int): [Organization]
}

type UpdateCartItemPayload {
    cartitem(filter: CartItemFilter, first: Int, offset: Int, order: CartItemOrder): [CartItem]
    numUids: Int
}

type UpdateCartPayload {
    cart(filter: CartFilter, first: Int, offset: Int, order: CartOrder): [Cart]
    numUids: Int
}

type UpdateCheckoutItemPayload {
    checkoutitem(filter: CheckoutItemFilter, first: Int, offset: Int, order: CheckoutItemOrder): [CheckoutItem]
    numUids: Int
}

type UpdateCheckoutPayload {
    checkout(filter: CheckoutFilter, first: Int, offset: Int, order: CheckoutOrder): [Checkout]
    numUids: Int
}

type UpdateConversationPayload {
    conversation(filter: ConversationFilter, first: Int, offset: Int, order: ConversationOrder): [Conversation]
    numUids: Int
}

type UpdateDataCatalogPayload {
    datacatalog(filter: DataCatalogFilter, first: Int, offset: Int, order: DataCatalogOrder): [DataCatalog]
    numUids: Int
}

type UpdateEmployeeRolePayload {
    employeerole(filter: EmployeeRoleFilter, first: Int, offset: Int, order: EmployeeRoleOrder): [EmployeeRole]
    numUids: Int
}

type UpdateEntryPointPayload {
    entrypoint(filter: EntryPointFilter, first: Int, offset: Int, order: EntryPointOrder): [EntryPoint]
    numUids: Int
}

type UpdateFollowerRolePayload {
    followerrole(filter: FollowerRoleFilter, first: Int, offset: Int, order: FollowerRoleOrder): [FollowerRole]
    numUids: Int
}

type UpdateGeneralOrganizationPayload {
    generalorganization(filter: GeneralOrganizationFilter, first: Int, offset: Int, order: GeneralOrganizationOrder): [GeneralOrganization]
    numUids: Int
}

type UpdateMemberRolePayload {
    memberrole(filter: MemberRoleFilter, first: Int, offset: Int, order: MemberRoleOrder): [MemberRole]
    numUids: Int
}

type UpdateMessagePayload {
    message(filter: MessageFilter, first: Int, offset: Int, order: MessageOrder): [Message]
    numUids: Int
}

type UpdateNamespacePayload {
    namespace(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace]
    numUids: Int
}

type UpdateOfferPayload {
    numUids: Int
    offer(filter: OfferFilter, first: Int, offset: Int, order: OfferOrder): [Offer]
}

type UpdateOwnershipPayload {
    numUids: Int
    ownership(filter: OwnershipFilter, first: Int, offset: Int, order: OwnershipOrder): [Ownership]
}

type UpdatePartyRoleNamePayload {
    numUids: Int
    partyrolename(filter: PartyRoleNameFilter, first: Int, offset: Int, order: PartyRoleNameOrder): [PartyRoleName]
}

type UpdatePersonPayload {
    numUids: Int
    person(filter: PersonFilter, first: Int, offset: Int, order: PersonOrder): [Person]
}

type UpdatePoderItemPayload {
    numUids: Int
    poderitem(filter: PoderItemFilter, first: Int, offset: Int, order: PoderItemOrder): [PoderItem]
}

type UpdatePoderPayload {
    numUids: Int
    poder(filter: PoderFilter, first: Int, offset: Int, order: PoderOrder): [Poder]
}

type UpdateProductModelPayload {
    numUids: Int
    productmodel(filter: ProductModelFilter, first: Int, offset: Int, order: ProductModelOrder): [ProductModel]
}

type UpdateProductPayload {
    numUids: Int
    product(filter: ProductFilter, first: Int, offset: Int, order: ProductOrder): [Product]
}

type UpdateReadNotePayload {
    numUids: Int
    readnote(filter: ReadNoteFilter, first: Int, offset: Int, order: ReadNoteOrder): [ReadNote]
}

type UpdateReviewPayload {
    numUids: Int
    review(filter: ReviewFilter, first: Int, offset: Int, order: ReviewOrder): [Review]
}

type UpdateSoftwareApplicationPayload {
    numUids: Int
    softwareapplication(filter: SoftwareApplicationFilter, first: Int, offset: Int, order: SoftwareApplicationOrder): [SoftwareApplication]
}

type UpdateStorePayload {
    numUids: Int
    store(filter: StoreFilter, first: Int, offset: Int, order: StoreOrder): [Store]
}

type UpdateThingPayload {
    numUids: Int
    thing(filter: ThingFilter, first: Int, offset: Int, order: ThingOrder): [Thing]
}

type UpdateUserPayload {
    numUids: Int
    user(filter: UserFilter, first: Int, offset: Int, order: UserOrder): [User]
}

type UpdateWebhookPayload {
    numUids: Int
    webhook(filter: WebhookFilter, first: Int, offset: Int, order: WebhookOrder): [Webhook]
}

"ç¨æ·è´¦å·"
type User implements Node & Thing {
    alternateName: String
    "    The user's public profile bio.    "
    bio: String
    description: String
    id: ID!
    identifier: String
    "    ç¨æ·è´¦å·å¯¹åºçäººï¼æè´¦å·ä¸å®æç¸å³çPersonï¼éå±æ§ Person.hasUserï¼åèInverse property: hasPart    "
    isUserOf(filter: PersonFilter): Person
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    The password used to login.    "
    password: String!
    "    The username used to login.    We also want to make sure that usernames are unique. The @id directive takes care of that - it also automatically adds hash searching, so we can drop the @search(by: [hash]), though having it also causes no harm.    "
    username: String!
}

"ç½ç»é©å­æ¯âç¨æ·å®ä¹çHTTPåè°âã[2]ç½ç»é©å­éå¸¸è¢«æäºäºä»¶æ¿æ´»ï¼æ¯å¦å°ä»£ç æ¨éå°æº[3]æè¯è®ºåå®¢ã[4]å½æ­¤äºä»¶åçæ¶ï¼åç½ç«å°åä¸ºç½ç»é©å­éç½®çURLåéHTTPè¯·æ±ãç¨æ·å¯éç½®å®ä»¬å¼åç½é¡µä¸çäºä»¶ä»¥è°ç¨å¦ä¸ä¸ªç½ç«çè¡ä¸ºãWebhooks allow external services to be notified when certain events happen."
type Webhook implements Node & Thing {
    alternateName: String
    "    è°ç¨æ­¤webhookçå®¢æ·ç«¯    "
    client(filter: SoftwareApplicationFilter): SoftwareApplication
    "    åè°æäº¤çæ°æ®åå®¹ç±»åå¦application/json    "
    contentType: String
    "    ãä½èã è¯¥ CreativeWork çåä½è/ä½èã    "
    creator(filter: UserFilter): User
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    id: ID!
    identifier: String
    name: String!
    namespaces(filter: NamespaceFilter, first: Int, offset: Int, order: NamespaceOrder): [Namespace!]
    "    åè°url    "
    payloadUrl: String
    "    ä½¿ç¨payloadUrlçå®å¨token    "
    secret: String
}

enum CartItemOrderable {
    alternateName
    createdAt
    description
    identifier
    name
    quantity
    updatedAt
}

"è´­ç©è½¦åç©åãæå¡ãä¼æ å¸ç­ç±»å"
enum CartItemType {
    SHIPPING
    SKU
    TAX
}

enum CartOrderable {
    alternateName
    createdAt
    description
    email
    identifier
    name
    notes
    updatedAt
}

enum CheckoutItemOrderable {
    alternateName
    description
    identifier
    name
    quantity
}

enum CheckoutOrderable {
    alternateName
    completedAt
    createdAt
    description
    email
    identifier
    name
    note
    updatedAt
}

enum ConversationOrderable {
    alternateName
    dateCreated
    description
    identifier
    name
}

enum DataCatalogOrderable {
    alternateName
    dateCreated
    description
    identifier
    name
}

enum DgraphIndex {
    bool
    day
    exact
    float
    fulltext
    hash
    hour
    int
    month
    regexp
    term
    trigram
    year
}

enum EmployeeRoleOrderable {
    alternateName
    dateFrom
    dateThrough
    description
    identifier
    name
    number
}

enum EntryPointOrderable {
    alternateName
    description
    identifier
    name
    urlTemplate
}

enum FollowerRoleOrderable {
    alternateName
    dateFrom
    dateThrough
    description
    identifier
    name
    settings
}

enum GeneralOrganizationOrderable {
    alternateName
    description
    identifier
    name
}

enum MemberRoleOrderable {
    alternateName
    dateFrom
    dateThrough
    description
    identifier
    name
    number
}

enum MessageOrderable {
    alternateName
    dateRead
    dateReceived
    dateSent
    description
    identifier
    name
}

enum NamespaceOrderable {
    alternateName
    description
    identifier
    name
    namespace
}

enum OfferOrderable {
    alternateName
    dateFrom
    dateThrough
    description
    identifier
    name
    price
}

enum OwnershipOrderable {
    alternateName
    dateFrom
    dateThrough
    description
    identifier
    name
}

enum PartyRoleNameOrderable {
    alternateName
    dateCreated
    description
    group
    identifier
    name
}

enum PartyRoleOrderable {
    dateFrom
    dateThrough
}

enum PersonOrderable {
    alternateName
    description
    familyName
    givenName
    identifier
    name
    personalID
}

enum PoderItemOrderable {
    alternateName
    description
    identifier
    name
    poderItemNumber
    poderQuantity
}

enum PoderOrderable {
    alternateName
    description
    identifier
    name
    poderDate
    poderNumber
}

enum PoderStatus {
    PoderCancelled
    PoderDelivered
    PoderInTransit
    PoderPAID
    PoderPaymentDue
    PoderPickupAvailable
    PoderProblem
    PoderProcessing
    PoderReturned
    PoderUNPAID
}

enum ProductModelOrderable {
    alternateName
    description
    identifier
    name
}

enum ProductOrderable {
    alternateName
    description
    identifier
    name
}

enum ReadNoteOrderable {
    alternateName
    dateRead
    description
    identifier
    name
}

enum ReviewOrderable {
    alternateName
    dateCreated
    description
    identifier
    name
    ratingValue
    reviewAspect
    reviewBody
}

enum SoftwareApplicationOrderable {
    alternateName
    applicationSuite
    description
    downloadUrl
    featureList
    identifier
    installUrl
    name
    releaseNotes
    screenshot
    softwareVersion
}

enum StoreOrderable {
    alternateName
    dateCreated
    dateModified
    description
    identifier
    name
}

enum ThingOrderable {
    alternateName
    description
    identifier
    name
}

enum UserOrderable {
    alternateName
    bio
    description
    identifier
    name
    password
    username
}

enum WebhookOrderable {
    alternateName
    contentType
    dateCreated
    description
    identifier
    name
    payloadUrl
    secret
}

input AddCartInput {
    alternateName: String
    createdAt: DateTime
    description: String
    email: String
    identifier: String
    items: [CartItemRef!]
    name: String!
    namespaces: [NamespaceRef!]
    notes: String
    owner: UserRef!
    updatedAt: DateTime
}

input AddCartItemInput {
    alternateName: String
    createdAt: DateTime!
    description: String
    identifier: String
    isItemOf: CartRef
    name: String!
    namespaces: [NamespaceRef!]
    quantity: Int!
    type: CartItemType!
    updatedAt: DateTime!
}

input AddCheckoutInput {
    alternateName: String
    "    The date and time when the checkout was completed.    "
    completedAt: DateTime
    "    The date and time when the checkout was created.    "
    createdAt: DateTime
    description: String
    "    The email attached to this checkout.    "
    email: String
    identifier: String
    items: [CheckoutItemRef]
    name: String!
    namespaces: [NamespaceRef!]
    "    The note associated with the checkout.    "
    note: String
    owner: UserRef!
    "    Whether or not the Checkout is ready and can be completed. Checkouts may have asynchronous operations that can take time to finish. If you want to complete a checkout or ensure all the fields are populated and up to date, polling is required until the value is true.    "
    ready: Boolean
    "    States whether or not the fulfillment requires shipping.    "
    requiresShipping: Boolean
    "    The date and time when the checkout was last updated.    "
    updatedAt: DateTime
}

input AddCheckoutItemInput {
    alternateName: String
    description: String
    identifier: String
    isItemOf: CheckoutRef
    name: String!
    namespaces: [NamespaceRef!]
    "    The quantity of the line item.    "
    quantity: Int!
}

input AddConversationInput {
    accountablePerson: UserRef
    alternateName: String
    creator: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    hasMessages: [MessageRef]
    identifier: String
    includedInDataCatalog: DataCatalogRef
    name: String!
    namespaces: [NamespaceRef!]
    webhook: [WebhookRef]
}

input AddDataCatalogInput {
    alternateName: String
    creator: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    identifier: String
    name: String!
    namespaces: [NamespaceRef!]
    parentDataCatalog: DataCatalogRef
    subDataCatalogs: [DataCatalogRef]
}

input AddEmployeeRoleInput {
    alternateName: String
    dateFrom: DateTime
    dateThrough: DateTime
    description: String
    identifier: String
    name: String!
    namespaces: [NamespaceRef!]
    "    ãåå·¥ç¼å·ã    "
    number: String
    person: PersonRef
    roleName: PartyRoleNameRef
}

input AddEntryPointInput {
    alternateName: String
    description: String
    identifier: String
    name: String!
    namespaces: [NamespaceRef!]
    "ãé¾æ¥æ¨¡çã ä¸ä¸ªURLçæ¨¡çï¼å¯ä»¥å©ç¨åååæ°å½¢æå®æ´çURLã An url template (RFC6570) that will be used to construct the target of the execution of the action."
    urlTemplate: String
}

input AddFollowerRoleInput {
    alternateName: String
    dateFrom: DateTime
    dateThrough: DateTime
    description: String
    identifier: String
    name: String!
    namespaces: [NamespaceRef!]
    person: PersonRef
    roleName: PartyRoleNameRef
    "å³æ³¨è®¾ç½®,å¦å³æ³¨ææ°äº§åä¿¡æ¯"
    settings: String
}

input AddGeneralOrganizationInput {
    alternateName: String
    availableConversations: [ConversationRef]
    defaultConversation: ConversationRef
    description: String
    hasNamespaces: [NamespaceRef!]
    hasPartyRoleName: [PartyRoleNameRef]
    identifier: String
    name: String!
    namespaces: [NamespaceRef!]
    owns: [OwnershipRef]
}

input AddMemberRoleInput {
    alternateName: String
    dateFrom: DateTime
    dateThrough: DateTime
    description: String
    identifier: String
    name: String!
    namespaces: [NamespaceRef!]
    "    ãä¼åç¼å·ã    "
    number: String
    person: PersonRef
    roleName: PartyRoleNameRef
}

input AddMessageInput {
    alternateName: String
    "    ãéè¯»æ¥æã å¦æå­å¨åä¸ªçæ¶ä»¶äººï¼å°±æ¯æ¶æ¯è¢«æ¶ä»¶äººè¯»åçæ¥æ/æ¶é´ã The date/time at which the message has been read by the recipient if a single recipient exists.    "
    dateRead: DateTime
    "    ãæ¥æ¶æ¥æã å¦æå­å¨åä¸ªçæ¶ä»¶äººï¼å°±æ¯æ¶æ¯è¢«æ¶ä»¶äººæ¥æ¶çæ¥æ/æ¶é´ã The date/time the message was received if a single recipient exists.    "
    dateReceived: DateTime
    "    ãåéæ¥æã æ¶æ¯è¢«åéçæ¥æ/æ¶é´ã The date/time at which the message was sent.    "
    dateSent: DateTime
    description: String
    hasReadNotes: [ReadNoteRef]
    hasReviews: [ReviewRef]
    identifier: String
    isMessageOf: [ConversationRef]
    name: String!
    namespaces: [NamespaceRef!]
    recipient: [UserRef]
    sender: UserRef!
    toRecipient: UserRef
}

input AddNamespaceInput {
    alternateName: String
    description: String
    identifier: String
    name: String!
    "    èµæºå¯¹è±¡æå±çnamespace,æ ¹æ®ä¸å®è§åç±å¹³å°çææéç½®å®ä¹å¦ï¼io.shurui.store001.order, é»è®¤å¼æ¯default    å¦ææä¸ªè§è²æ¥æinamespaceï¼'io.shurui'çæéï¼åæ¥æ'io.shurui'ä¸ä¸ææå­namespaceçç¸åºæé    "
    namespace: String
    namespaces: [NamespaceRef!]
}

input AddOfferInput {
    alternateName: String
    "    ãä»·æ ¼ææå¼å§æ¥æã    "
    dateFrom: DateTime
    "    ãä»·æ ¼ææç»ææ¥æã    "
    dateThrough: DateTime
    description: String
    identifier: String
    name: String!
    namespaces: [NamespaceRef!]
    "    ååä»·æ ¼The offer price of a product, or of a price component when attached to PriceSpecification and its subtypes.    "
    price: Int
}

input AddOwnershipInput {
    alternateName: String
    "    ãå¼å§æ¥æã æäºçå¼å§æ¥æåæ¶é´    "
    dateFrom: DateTime
    "    ãç»ææ¥æã æ´»å¨ï¼äºä»¶ï¼ç»ææ¶é´ã The end date and time of the item (in ISO 8601 date format).    "
    dateThrough: DateTime
    description: String
    identifier: String
    name: String!
    namespaces: [NamespaceRef!]
}

input AddPartyRoleNameInput {
    alternateName: String
    creator: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    "    è§è²åç»,å¦åå·¥è§è²ç»ãä¼åè§è²ç»    "
    group: String
    identifier: String
    name: String!
    namespaces: [NamespaceRef!]
}

input AddPersonInput {
    alternateName: String
    description: String
    "ãå§ã å§ã å¨ç¾å½ï¼æ¯ä¸ä¸ªäººå§åä¸­çæåä¸ä¸ªå­ã Family name. In the U.S., the last name of an Person. This can be used along with givenName instead of the name property."
    familyName: String
    "ãåã åãå¨ç¾å½ï¼æ¯ä¸ä¸ªäººåå­ä¸­çç¬¬ä¸ä¸ªå­ Given name. In the U.S., the first name of a Person. This can be used along with familyName instead of the name property."
    givenName: String
    hasNamespaces: [NamespaceRef!]
    hasUser: UserRef
    identifier: String
    name: String!
    namespaces: [NamespaceRef!]
    owns: [OwnershipRef]
    "    ä¸ªäººèº«ä»½è¯ID    "
    personalID: String!
}

input AddPoderInput {
    alternateName: String
    description: String
    identifier: String
    "    discount    Number  or Text    Any discount applied (to an Poder).    discountCode    Text    Code used to redeem a discount.    discountCurrency    Text    The currency of the discount.    Use standard formats: ISO 4217 currency format e.g. \"USD\"; Ticker symbol for cryptocurrencies e.g. \"BTC\"; well known names for Local Exchange Tradings Systems (LETS) and other currency types e.g. \"Ithaca HOUR\".    isGift    Boolean    Was the offer accepted as a gift for someone other than the buyer.    "
    isGift: Boolean
    items: [PoderItemRef]
    name: String!
    namespaces: [NamespaceRef!]
    "    poderDate    DateTime  or DateTime    DateTime poder was placed.    "
    poderDate: DateTime
    "    poderNumber    Text    The identifier of the transaction.    "
    poderNumber: String
    "    poderStatus    PoderStatus    The current status of the poder.    "
    poderStatus: PoderStatus
}

input AddPoderItemInput {
    alternateName: String
    description: String
    identifier: String
    isItemOf: PoderRef
    name: String!
    namespaces: [NamespaceRef!]
    "    poderItemNumber    Text    The identifier of the poder item.    "
    poderItemNumber: String
    "    poderItemStatus    PoderStatus    The current status of the poder item.    "
    poderItemStatus: PoderStatus
    "    poderQuantity    Number    The number of the item podered. If the property is not set, assume the quantity is one.    "
    poderQuantity: Int
}

input AddProductInput {
    alternateName: String
    description: String
    hasModels: [ProductModelRef]
    identifier: String
    isShoppingable: Boolean
    name: String!
    namespaces: [NamespaceRef!]
}

input AddProductModelInput {
    alternateName: String
    description: String
    identifier: String
    isModelOf: ProductRef
    isShoppingable: Boolean
    name: String!
    namespaces: [NamespaceRef!]
}

input AddReadNoteInput {
    alternateName: String
    "    ãéè¯»æ¥æã    "
    dateRead: DateTime
    description: String
    identifier: String
    name: String!
    namespaces: [NamespaceRef!]
    reader: UserRef
}

input AddReviewInput {
    alternateName: String
    author: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã    "
    dateCreated: DateTime
    description: String
    identifier: String
    name: String!
    namespaces: [NamespaceRef!]
    "    ratingValue    è¯å The rating for the content.    "
    ratingValue: Int
    "reviewAspect    Text    This Review or Rating is relevant to this part or facet of the itemReviewed."
    reviewAspect: String
    "reviewBody    Text    The actual body of the review."
    reviewBody: String
}

input AddSoftwareApplicationInput {
    alternateName: String
    "    applicationSuite    Text    The name of the application suite to which the application belongs (e.g. Excel belongs to Office).    "
    applicationSuite: String
    description: String
    "    availableOnDevice    Text    Device required to run the application. Used in cases where a specific make/model is required to run the application. Supersedes device.    countriesNotSupported    Text    Countries for which the application is not supported. You can also provide the two-letter ISO 3166-1 alpha-2 country code.    countriesSupported    Text    Countries for which the application is supported. You can also provide the two-letter ISO 3166-1 alpha-2 country code.    downloadUrl    URL    If the file can be downloaded, URL to download the binary.    "
    downloadUrl: String
    "    featureList    Text  or URL    Features or modules provided by this application (and possibly required by other applications).    "
    featureList: String
    identifier: String
    "    fileSize    Text    Size of the application / package (e.g. 18MB). In the absence of a unit (MB, KB etc.), KB will be assumed.    installUrl    URL    URL at which the app may be installed, if different from the URL of the item.    "
    installUrl: String
    name: String!
    namespaces: [NamespaceRef!]
    "    memoryRequirements    Text  or URL    Minimum memory requirements.    operatingSystem    Text    Operating systems supported (Windows 7, OSX 10.6, Android 1.6).    permissions    Text    Permission(s) required to run the app (for example, a mobile app may require full internet access or may run only on wifi).    processorRequirements    Text    Processor architecture required to run the application (e.g. IA64).    releaseNotes    Text  or URL    Description of what changed in this version.    "
    releaseNotes: String
    "    screenshot    ImageObject  or URL    A link to a screenshot image of the app.    "
    screenshot: String
    "    softwareAddOn    SoftwareApplication    Additional content for a software application.    softwareHelp    CreativeWork    Software application help.    softwareRequirements    Text  or URL    Component dependency requirements for application. This includes runtime environments and shared libraries that are not included in the application distribution package, but required to run the application (Examples: DirectX, Java or .NET runtime). Supersedes requirements.    softwareVersion    Text    Version of the software instance.    storageRequirements    Text  or URL    Storage requirements (free space required).    supportingData    DataFeed    Supporting data for a SoftwareApplication.    "
    softwareVersion: String
}

input AddStoreInput {
    alternateName: String
    creator: UserRef
    "    ãåå»ºæ¥æã    "
    dateCreated: DateTime
    "    ãæ´æ°æ¥æã    "
    dateModified: DateTime
    description: String
    employees: [EmployeeRoleRef]
    followers: [FollowerRoleRef]
    hasNamespaces: [NamespaceRef!]
    hasPartyRoleName: [PartyRoleNameRef]
    identifier: String
    members: [MemberRoleRef]
    name: String!
    namespaces: [NamespaceRef!]
    owns: [OwnershipRef]
}

input AddUserInput {
    alternateName: String
    "    The user's public profile bio.    "
    bio: String
    description: String
    identifier: String
    isUserOf: PersonRef
    name: String!
    namespaces: [NamespaceRef!]
    "    The password used to login.    "
    password: String!
    "    The username used to login.    We also want to make sure that usernames are unique. The @id directive takes care of that - it also automatically adds hash searching, so we can drop the @search(by: [hash]), though having it also causes no harm.    "
    username: String!
}

input AddWebhookInput {
    alternateName: String
    client: SoftwareApplicationRef
    "    åè°æäº¤çæ°æ®åå®¹ç±»åå¦application/json    "
    contentType: String
    creator: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    identifier: String
    name: String!
    namespaces: [NamespaceRef!]
    "    åè°url    "
    payloadUrl: String
    "    ä½¿ç¨payloadUrlçå®å¨token    "
    secret: String
}

input CartFilter {
    and: CartFilter
    id: [ID!]
    name: StringHashFilter
    not: CartFilter
    or: CartFilter
}

input CartItemFilter {
    and: CartItemFilter
    id: [ID!]
    name: StringHashFilter
    not: CartItemFilter
    or: CartItemFilter
}

input CartItemOrder {
    asc: CartItemOrderable
    desc: CartItemOrderable
    then: CartItemOrder
}

input CartItemPatch {
    alternateName: String
    createdAt: DateTime
    description: String
    identifier: String
    isItemOf: CartRef
    name: String
    namespaces: [NamespaceRef!]
    quantity: Int
    type: CartItemType
    updatedAt: DateTime
}

input CartItemRef {
    alternateName: String
    createdAt: DateTime
    description: String
    id: ID
    identifier: String
    isItemOf: CartRef
    name: String
    namespaces: [NamespaceRef!]
    quantity: Int
    type: CartItemType
    updatedAt: DateTime
}

input CartOrder {
    asc: CartOrderable
    desc: CartOrderable
    then: CartOrder
}

input CartPatch {
    alternateName: String
    createdAt: DateTime
    description: String
    email: String
    identifier: String
    items: [CartItemRef!]
    name: String
    namespaces: [NamespaceRef!]
    notes: String
    owner: UserRef
    updatedAt: DateTime
}

input CartRef {
    alternateName: String
    createdAt: DateTime
    description: String
    email: String
    id: ID
    identifier: String
    items: [CartItemRef!]
    name: String
    namespaces: [NamespaceRef!]
    notes: String
    owner: UserRef
    updatedAt: DateTime
}

input CheckoutFilter {
    and: CheckoutFilter
    id: [ID!]
    name: StringHashFilter
    not: CheckoutFilter
    or: CheckoutFilter
}

input CheckoutItemFilter {
    and: CheckoutItemFilter
    id: [ID!]
    name: StringHashFilter
    not: CheckoutItemFilter
    or: CheckoutItemFilter
}

input CheckoutItemOrder {
    asc: CheckoutItemOrderable
    desc: CheckoutItemOrderable
    then: CheckoutItemOrder
}

input CheckoutItemPatch {
    alternateName: String
    description: String
    identifier: String
    isItemOf: CheckoutRef
    name: String
    namespaces: [NamespaceRef!]
    "    The quantity of the line item.    "
    quantity: Int
}

input CheckoutItemRef {
    alternateName: String
    description: String
    id: ID
    identifier: String
    isItemOf: CheckoutRef
    name: String
    namespaces: [NamespaceRef!]
    "    The quantity of the line item.    "
    quantity: Int
}

input CheckoutOrder {
    asc: CheckoutOrderable
    desc: CheckoutOrderable
    then: CheckoutOrder
}

input CheckoutPatch {
    alternateName: String
    "    The date and time when the checkout was completed.    "
    completedAt: DateTime
    "    The date and time when the checkout was created.    "
    createdAt: DateTime
    description: String
    "    The email attached to this checkout.    "
    email: String
    identifier: String
    items: [CheckoutItemRef]
    name: String
    namespaces: [NamespaceRef!]
    "    The note associated with the checkout.    "
    note: String
    owner: UserRef
    "    Whether or not the Checkout is ready and can be completed. Checkouts may have asynchronous operations that can take time to finish. If you want to complete a checkout or ensure all the fields are populated and up to date, polling is required until the value is true.    "
    ready: Boolean
    "    States whether or not the fulfillment requires shipping.    "
    requiresShipping: Boolean
    "    The date and time when the checkout was last updated.    "
    updatedAt: DateTime
}

input CheckoutRef {
    alternateName: String
    "    The date and time when the checkout was completed.    "
    completedAt: DateTime
    "    The date and time when the checkout was created.    "
    createdAt: DateTime
    description: String
    "    The email attached to this checkout.    "
    email: String
    id: ID
    identifier: String
    items: [CheckoutItemRef]
    name: String
    namespaces: [NamespaceRef!]
    "    The note associated with the checkout.    "
    note: String
    owner: UserRef
    "    Whether or not the Checkout is ready and can be completed. Checkouts may have asynchronous operations that can take time to finish. If you want to complete a checkout or ensure all the fields are populated and up to date, polling is required until the value is true.    "
    ready: Boolean
    "    States whether or not the fulfillment requires shipping.    "
    requiresShipping: Boolean
    "    The date and time when the checkout was last updated.    "
    updatedAt: DateTime
}

input ConversationFilter {
    and: ConversationFilter
    id: [ID!]
    name: StringHashFilter
    not: ConversationFilter
    or: ConversationFilter
}

input ConversationOrder {
    asc: ConversationOrderable
    desc: ConversationOrderable
    then: ConversationOrder
}

input ConversationPatch {
    accountablePerson: UserRef
    alternateName: String
    creator: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    hasMessages: [MessageRef]
    identifier: String
    includedInDataCatalog: DataCatalogRef
    name: String
    namespaces: [NamespaceRef!]
    webhook: [WebhookRef]
}

input ConversationRef {
    accountablePerson: UserRef
    alternateName: String
    creator: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    hasMessages: [MessageRef]
    id: ID
    identifier: String
    includedInDataCatalog: DataCatalogRef
    name: String
    namespaces: [NamespaceRef!]
    webhook: [WebhookRef]
}

input DataCatalogFilter {
    and: DataCatalogFilter
    id: [ID!]
    name: StringHashFilter
    not: DataCatalogFilter
    or: DataCatalogFilter
}

input DataCatalogOrder {
    asc: DataCatalogOrderable
    desc: DataCatalogOrderable
    then: DataCatalogOrder
}

input DataCatalogPatch {
    alternateName: String
    creator: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    parentDataCatalog: DataCatalogRef
    subDataCatalogs: [DataCatalogRef]
}

input DataCatalogRef {
    alternateName: String
    creator: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    id: ID
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    parentDataCatalog: DataCatalogRef
    subDataCatalogs: [DataCatalogRef]
}

input DateTimeFilter {
    eq: DateTime
    ge: DateTime
    gt: DateTime
    le: DateTime
    lt: DateTime
}

input EmployeeRoleFilter {
    and: EmployeeRoleFilter
    id: [ID!]
    name: StringHashFilter
    not: EmployeeRoleFilter
    or: EmployeeRoleFilter
}

input EmployeeRoleOrder {
    asc: EmployeeRoleOrderable
    desc: EmployeeRoleOrderable
    then: EmployeeRoleOrder
}

input EmployeeRolePatch {
    alternateName: String
    dateFrom: DateTime
    dateThrough: DateTime
    description: String
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    "    ãåå·¥ç¼å·ã    "
    number: String
    person: PersonRef
    roleName: PartyRoleNameRef
}

input EmployeeRoleRef {
    alternateName: String
    dateFrom: DateTime
    dateThrough: DateTime
    description: String
    id: ID
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    "    ãåå·¥ç¼å·ã    "
    number: String
    person: PersonRef
    roleName: PartyRoleNameRef
}

input EntryPointFilter {
    and: EntryPointFilter
    id: [ID!]
    name: StringHashFilter
    not: EntryPointFilter
    or: EntryPointFilter
}

input EntryPointOrder {
    asc: EntryPointOrderable
    desc: EntryPointOrderable
    then: EntryPointOrder
}

input EntryPointPatch {
    alternateName: String
    description: String
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    "ãé¾æ¥æ¨¡çã ä¸ä¸ªURLçæ¨¡çï¼å¯ä»¥å©ç¨åååæ°å½¢æå®æ´çURLã An url template (RFC6570) that will be used to construct the target of the execution of the action."
    urlTemplate: String
}

input EntryPointRef {
    alternateName: String
    description: String
    id: ID
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    "ãé¾æ¥æ¨¡çã ä¸ä¸ªURLçæ¨¡çï¼å¯ä»¥å©ç¨åååæ°å½¢æå®æ´çURLã An url template (RFC6570) that will be used to construct the target of the execution of the action."
    urlTemplate: String
}

input FloatFilter {
    eq: Float
    ge: Float
    gt: Float
    le: Float
    lt: Float
}

input FollowerRoleFilter {
    and: FollowerRoleFilter
    id: [ID!]
    name: StringHashFilter
    not: FollowerRoleFilter
    or: FollowerRoleFilter
}

input FollowerRoleOrder {
    asc: FollowerRoleOrderable
    desc: FollowerRoleOrderable
    then: FollowerRoleOrder
}

input FollowerRolePatch {
    alternateName: String
    dateFrom: DateTime
    dateThrough: DateTime
    description: String
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    person: PersonRef
    roleName: PartyRoleNameRef
    "å³æ³¨è®¾ç½®,å¦å³æ³¨ææ°äº§åä¿¡æ¯"
    settings: String
}

input FollowerRoleRef {
    alternateName: String
    dateFrom: DateTime
    dateThrough: DateTime
    description: String
    id: ID
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    person: PersonRef
    roleName: PartyRoleNameRef
    "å³æ³¨è®¾ç½®,å¦å³æ³¨ææ°äº§åä¿¡æ¯"
    settings: String
}

input GeneralOrganizationFilter {
    and: GeneralOrganizationFilter
    id: [ID!]
    name: StringHashFilter
    not: GeneralOrganizationFilter
    or: GeneralOrganizationFilter
}

input GeneralOrganizationOrder {
    asc: GeneralOrganizationOrderable
    desc: GeneralOrganizationOrderable
    then: GeneralOrganizationOrder
}

input GeneralOrganizationPatch {
    alternateName: String
    availableConversations: [ConversationRef]
    defaultConversation: ConversationRef
    description: String
    hasNamespaces: [NamespaceRef!]
    hasPartyRoleName: [PartyRoleNameRef]
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    owns: [OwnershipRef]
}

input GeneralOrganizationRef {
    alternateName: String
    availableConversations: [ConversationRef]
    defaultConversation: ConversationRef
    description: String
    hasNamespaces: [NamespaceRef!]
    hasPartyRoleName: [PartyRoleNameRef]
    id: ID
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    owns: [OwnershipRef]
}

input IntFilter {
    eq: Int
    ge: Int
    gt: Int
    le: Int
    lt: Int
}

input MemberRoleFilter {
    and: MemberRoleFilter
    id: [ID!]
    name: StringHashFilter
    not: MemberRoleFilter
    or: MemberRoleFilter
}

input MemberRoleOrder {
    asc: MemberRoleOrderable
    desc: MemberRoleOrderable
    then: MemberRoleOrder
}

input MemberRolePatch {
    alternateName: String
    dateFrom: DateTime
    dateThrough: DateTime
    description: String
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    "    ãä¼åç¼å·ã    "
    number: String
    person: PersonRef
    roleName: PartyRoleNameRef
}

input MemberRoleRef {
    alternateName: String
    dateFrom: DateTime
    dateThrough: DateTime
    description: String
    id: ID
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    "    ãä¼åç¼å·ã    "
    number: String
    person: PersonRef
    roleName: PartyRoleNameRef
}

input MessageFilter {
    and: MessageFilter
    id: [ID!]
    name: StringHashFilter
    not: MessageFilter
    or: MessageFilter
}

input MessageOrder {
    asc: MessageOrderable
    desc: MessageOrderable
    then: MessageOrder
}

input MessagePatch {
    alternateName: String
    "    ãéè¯»æ¥æã å¦æå­å¨åä¸ªçæ¶ä»¶äººï¼å°±æ¯æ¶æ¯è¢«æ¶ä»¶äººè¯»åçæ¥æ/æ¶é´ã The date/time at which the message has been read by the recipient if a single recipient exists.    "
    dateRead: DateTime
    "    ãæ¥æ¶æ¥æã å¦æå­å¨åä¸ªçæ¶ä»¶äººï¼å°±æ¯æ¶æ¯è¢«æ¶ä»¶äººæ¥æ¶çæ¥æ/æ¶é´ã The date/time the message was received if a single recipient exists.    "
    dateReceived: DateTime
    "    ãåéæ¥æã æ¶æ¯è¢«åéçæ¥æ/æ¶é´ã The date/time at which the message was sent.    "
    dateSent: DateTime
    description: String
    hasReadNotes: [ReadNoteRef]
    hasReviews: [ReviewRef]
    identifier: String
    isMessageOf: [ConversationRef]
    name: String
    namespaces: [NamespaceRef!]
    recipient: [UserRef]
    sender: UserRef
    toRecipient: UserRef
}

input MessageRef {
    alternateName: String
    "    ãéè¯»æ¥æã å¦æå­å¨åä¸ªçæ¶ä»¶äººï¼å°±æ¯æ¶æ¯è¢«æ¶ä»¶äººè¯»åçæ¥æ/æ¶é´ã The date/time at which the message has been read by the recipient if a single recipient exists.    "
    dateRead: DateTime
    "    ãæ¥æ¶æ¥æã å¦æå­å¨åä¸ªçæ¶ä»¶äººï¼å°±æ¯æ¶æ¯è¢«æ¶ä»¶äººæ¥æ¶çæ¥æ/æ¶é´ã The date/time the message was received if a single recipient exists.    "
    dateReceived: DateTime
    "    ãåéæ¥æã æ¶æ¯è¢«åéçæ¥æ/æ¶é´ã The date/time at which the message was sent.    "
    dateSent: DateTime
    description: String
    hasReadNotes: [ReadNoteRef]
    hasReviews: [ReviewRef]
    id: ID
    identifier: String
    isMessageOf: [ConversationRef]
    name: String
    namespaces: [NamespaceRef!]
    recipient: [UserRef]
    sender: UserRef
    toRecipient: UserRef
}

input NamespaceFilter {
    and: NamespaceFilter
    id: [ID!]
    name: StringHashFilter
    namespace: StringExactFilter_StringRegExpFilter
    not: NamespaceFilter
    or: NamespaceFilter
}

input NamespaceOrder {
    asc: NamespaceOrderable
    desc: NamespaceOrderable
    then: NamespaceOrder
}

input NamespacePatch {
    alternateName: String
    description: String
    identifier: String
    name: String
    "    èµæºå¯¹è±¡æå±çnamespace,æ ¹æ®ä¸å®è§åç±å¹³å°çææéç½®å®ä¹å¦ï¼io.shurui.store001.order, é»è®¤å¼æ¯default    å¦ææä¸ªè§è²æ¥æinamespaceï¼'io.shurui'çæéï¼åæ¥æ'io.shurui'ä¸ä¸ææå­namespaceçç¸åºæé    "
    namespace: String
    namespaces: [NamespaceRef!]
}

input NamespaceRef {
    alternateName: String
    description: String
    id: ID
    identifier: String
    name: String
    "    èµæºå¯¹è±¡æå±çnamespace,æ ¹æ®ä¸å®è§åç±å¹³å°çææéç½®å®ä¹å¦ï¼io.shurui.store001.order, é»è®¤å¼æ¯default    å¦ææä¸ªè§è²æ¥æinamespaceï¼'io.shurui'çæéï¼åæ¥æ'io.shurui'ä¸ä¸ææå­namespaceçç¸åºæé    "
    namespace: String
    namespaces: [NamespaceRef!]
}

input NodeFilter {
    id: [ID!]
    not: NodeFilter
}

input NodeRef {
    "    The id of the thing.    The id: ID! in Thing means that an auto-generated ID by Dgraph will be used to identify things.    "
    id: ID!
}

input OfferFilter {
    and: OfferFilter
    id: [ID!]
    name: StringHashFilter
    not: OfferFilter
    or: OfferFilter
}

input OfferOrder {
    asc: OfferOrderable
    desc: OfferOrderable
    then: OfferOrder
}

input OfferPatch {
    alternateName: String
    "    ãä»·æ ¼ææå¼å§æ¥æã    "
    dateFrom: DateTime
    "    ãä»·æ ¼ææç»ææ¥æã    "
    dateThrough: DateTime
    description: String
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    "    ååä»·æ ¼The offer price of a product, or of a price component when attached to PriceSpecification and its subtypes.    "
    price: Int
}

input OfferRef {
    alternateName: String
    "    ãä»·æ ¼ææå¼å§æ¥æã    "
    dateFrom: DateTime
    "    ãä»·æ ¼ææç»ææ¥æã    "
    dateThrough: DateTime
    description: String
    id: ID
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    "    ååä»·æ ¼The offer price of a product, or of a price component when attached to PriceSpecification and its subtypes.    "
    price: Int
}

input OwnershipFilter {
    and: OwnershipFilter
    id: [ID!]
    name: StringHashFilter
    not: OwnershipFilter
    or: OwnershipFilter
}

input OwnershipOrder {
    asc: OwnershipOrderable
    desc: OwnershipOrderable
    then: OwnershipOrder
}

input OwnershipPatch {
    alternateName: String
    "    ãå¼å§æ¥æã æäºçå¼å§æ¥æåæ¶é´    "
    dateFrom: DateTime
    "    ãç»ææ¥æã æ´»å¨ï¼äºä»¶ï¼ç»ææ¶é´ã The end date and time of the item (in ISO 8601 date format).    "
    dateThrough: DateTime
    description: String
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
}

input OwnershipRef {
    alternateName: String
    "    ãå¼å§æ¥æã æäºçå¼å§æ¥æåæ¶é´    "
    dateFrom: DateTime
    "    ãç»ææ¥æã æ´»å¨ï¼äºä»¶ï¼ç»ææ¶é´ã The end date and time of the item (in ISO 8601 date format).    "
    dateThrough: DateTime
    description: String
    id: ID
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
}

input PartyRoleNameFilter {
    and: PartyRoleNameFilter
    id: [ID!]
    name: StringHashFilter
    not: PartyRoleNameFilter
    or: PartyRoleNameFilter
}

input PartyRoleNameOrder {
    asc: PartyRoleNameOrderable
    desc: PartyRoleNameOrderable
    then: PartyRoleNameOrder
}

input PartyRoleNamePatch {
    alternateName: String
    creator: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    "    è§è²åç»,å¦åå·¥è§è²ç»ãä¼åè§è²ç»    "
    group: String
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
}

input PartyRoleNameRef {
    alternateName: String
    creator: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    "    è§è²åç»,å¦åå·¥è§è²ç»ãä¼åè§è²ç»    "
    group: String
    id: ID
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
}

input PartyRoleOrder {
    asc: PartyRoleOrderable
    desc: PartyRoleOrderable
    then: PartyRoleOrder
}

input PersonFilter {
    and: PersonFilter
    id: [ID!]
    name: StringHashFilter
    not: PersonFilter
    or: PersonFilter
}

input PersonOrder {
    asc: PersonOrderable
    desc: PersonOrderable
    then: PersonOrder
}

input PersonPatch {
    alternateName: String
    description: String
    "ãå§ã å§ã å¨ç¾å½ï¼æ¯ä¸ä¸ªäººå§åä¸­çæåä¸ä¸ªå­ã Family name. In the U.S., the last name of an Person. This can be used along with givenName instead of the name property."
    familyName: String
    "ãåã åãå¨ç¾å½ï¼æ¯ä¸ä¸ªäººåå­ä¸­çç¬¬ä¸ä¸ªå­ Given name. In the U.S., the first name of a Person. This can be used along with familyName instead of the name property."
    givenName: String
    hasNamespaces: [NamespaceRef!]
    hasUser: UserRef
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    owns: [OwnershipRef]
    "    ä¸ªäººèº«ä»½è¯ID    "
    personalID: String
}

input PersonRef {
    alternateName: String
    description: String
    "ãå§ã å§ã å¨ç¾å½ï¼æ¯ä¸ä¸ªäººå§åä¸­çæåä¸ä¸ªå­ã Family name. In the U.S., the last name of an Person. This can be used along with givenName instead of the name property."
    familyName: String
    "ãåã åãå¨ç¾å½ï¼æ¯ä¸ä¸ªäººåå­ä¸­çç¬¬ä¸ä¸ªå­ Given name. In the U.S., the first name of a Person. This can be used along with familyName instead of the name property."
    givenName: String
    hasNamespaces: [NamespaceRef!]
    hasUser: UserRef
    id: ID
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    owns: [OwnershipRef]
    "    ä¸ªäººèº«ä»½è¯ID    "
    personalID: String
}

input PoderFilter {
    and: PoderFilter
    id: [ID!]
    name: StringHashFilter
    not: PoderFilter
    or: PoderFilter
}

input PoderItemFilter {
    and: PoderItemFilter
    id: [ID!]
    name: StringHashFilter
    not: PoderItemFilter
    or: PoderItemFilter
}

input PoderItemOrder {
    asc: PoderItemOrderable
    desc: PoderItemOrderable
    then: PoderItemOrder
}

input PoderItemPatch {
    alternateName: String
    description: String
    identifier: String
    isItemOf: PoderRef
    name: String
    namespaces: [NamespaceRef!]
    "    poderItemNumber    Text    The identifier of the poder item.    "
    poderItemNumber: String
    "    poderItemStatus    PoderStatus    The current status of the poder item.    "
    poderItemStatus: PoderStatus
    "    poderQuantity    Number    The number of the item podered. If the property is not set, assume the quantity is one.    "
    poderQuantity: Int
}

input PoderItemRef {
    alternateName: String
    description: String
    id: ID
    identifier: String
    isItemOf: PoderRef
    name: String
    namespaces: [NamespaceRef!]
    "    poderItemNumber    Text    The identifier of the poder item.    "
    poderItemNumber: String
    "    poderItemStatus    PoderStatus    The current status of the poder item.    "
    poderItemStatus: PoderStatus
    "    poderQuantity    Number    The number of the item podered. If the property is not set, assume the quantity is one.    "
    poderQuantity: Int
}

input PoderOrder {
    asc: PoderOrderable
    desc: PoderOrderable
    then: PoderOrder
}

input PoderPatch {
    alternateName: String
    description: String
    identifier: String
    "    discount    Number  or Text    Any discount applied (to an Poder).    discountCode    Text    Code used to redeem a discount.    discountCurrency    Text    The currency of the discount.    Use standard formats: ISO 4217 currency format e.g. \"USD\"; Ticker symbol for cryptocurrencies e.g. \"BTC\"; well known names for Local Exchange Tradings Systems (LETS) and other currency types e.g. \"Ithaca HOUR\".    isGift    Boolean    Was the offer accepted as a gift for someone other than the buyer.    "
    isGift: Boolean
    items: [PoderItemRef]
    name: String
    namespaces: [NamespaceRef!]
    "    poderDate    DateTime  or DateTime    DateTime poder was placed.    "
    poderDate: DateTime
    "    poderNumber    Text    The identifier of the transaction.    "
    poderNumber: String
    "    poderStatus    PoderStatus    The current status of the poder.    "
    poderStatus: PoderStatus
}

input PoderRef {
    alternateName: String
    description: String
    id: ID
    identifier: String
    "    discount    Number  or Text    Any discount applied (to an Poder).    discountCode    Text    Code used to redeem a discount.    discountCurrency    Text    The currency of the discount.    Use standard formats: ISO 4217 currency format e.g. \"USD\"; Ticker symbol for cryptocurrencies e.g. \"BTC\"; well known names for Local Exchange Tradings Systems (LETS) and other currency types e.g. \"Ithaca HOUR\".    isGift    Boolean    Was the offer accepted as a gift for someone other than the buyer.    "
    isGift: Boolean
    items: [PoderItemRef]
    name: String
    namespaces: [NamespaceRef!]
    "    poderDate    DateTime  or DateTime    DateTime poder was placed.    "
    poderDate: DateTime
    "    poderNumber    Text    The identifier of the transaction.    "
    poderNumber: String
    "    poderStatus    PoderStatus    The current status of the poder.    "
    poderStatus: PoderStatus
}

input ProductFilter {
    and: ProductFilter
    id: [ID!]
    name: StringHashFilter
    not: ProductFilter
    or: ProductFilter
}

input ProductModelFilter {
    and: ProductModelFilter
    id: [ID!]
    name: StringHashFilter
    not: ProductModelFilter
    or: ProductModelFilter
}

input ProductModelOrder {
    asc: ProductModelOrderable
    desc: ProductModelOrderable
    then: ProductModelOrder
}

input ProductModelPatch {
    alternateName: String
    description: String
    identifier: String
    isModelOf: ProductRef
    isShoppingable: Boolean
    name: String
    namespaces: [NamespaceRef!]
}

input ProductModelRef {
    alternateName: String
    description: String
    id: ID
    identifier: String
    isModelOf: ProductRef
    isShoppingable: Boolean
    name: String
    namespaces: [NamespaceRef!]
}

input ProductOrder {
    asc: ProductOrderable
    desc: ProductOrderable
    then: ProductOrder
}

input ProductPatch {
    alternateName: String
    description: String
    hasModels: [ProductModelRef]
    identifier: String
    isShoppingable: Boolean
    name: String
    namespaces: [NamespaceRef!]
}

input ProductRef {
    alternateName: String
    description: String
    hasModels: [ProductModelRef]
    id: ID
    identifier: String
    isShoppingable: Boolean
    name: String
    namespaces: [NamespaceRef!]
}

input ReadNoteFilter {
    and: ReadNoteFilter
    id: [ID!]
    name: StringHashFilter
    not: ReadNoteFilter
    or: ReadNoteFilter
}

input ReadNoteOrder {
    asc: ReadNoteOrderable
    desc: ReadNoteOrderable
    then: ReadNoteOrder
}

input ReadNotePatch {
    alternateName: String
    "    ãéè¯»æ¥æã    "
    dateRead: DateTime
    description: String
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    reader: UserRef
}

input ReadNoteRef {
    alternateName: String
    "    ãéè¯»æ¥æã    "
    dateRead: DateTime
    description: String
    id: ID
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    reader: UserRef
}

input ReviewFilter {
    and: ReviewFilter
    id: [ID!]
    name: StringHashFilter
    not: ReviewFilter
    or: ReviewFilter
}

input ReviewOrder {
    asc: ReviewOrderable
    desc: ReviewOrderable
    then: ReviewOrder
}

input ReviewPatch {
    alternateName: String
    author: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã    "
    dateCreated: DateTime
    description: String
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    "    ratingValue    è¯å The rating for the content.    "
    ratingValue: Int
    "reviewAspect    Text    This Review or Rating is relevant to this part or facet of the itemReviewed."
    reviewAspect: String
    "reviewBody    Text    The actual body of the review."
    reviewBody: String
}

input ReviewRef {
    alternateName: String
    author: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã    "
    dateCreated: DateTime
    description: String
    id: ID
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    "    ratingValue    è¯å The rating for the content.    "
    ratingValue: Int
    "reviewAspect    Text    This Review or Rating is relevant to this part or facet of the itemReviewed."
    reviewAspect: String
    "reviewBody    Text    The actual body of the review."
    reviewBody: String
}

input SoftwareApplicationFilter {
    and: SoftwareApplicationFilter
    id: [ID!]
    name: StringHashFilter
    not: SoftwareApplicationFilter
    or: SoftwareApplicationFilter
}

input SoftwareApplicationOrder {
    asc: SoftwareApplicationOrderable
    desc: SoftwareApplicationOrderable
    then: SoftwareApplicationOrder
}

input SoftwareApplicationPatch {
    alternateName: String
    "    applicationSuite    Text    The name of the application suite to which the application belongs (e.g. Excel belongs to Office).    "
    applicationSuite: String
    description: String
    "    availableOnDevice    Text    Device required to run the application. Used in cases where a specific make/model is required to run the application. Supersedes device.    countriesNotSupported    Text    Countries for which the application is not supported. You can also provide the two-letter ISO 3166-1 alpha-2 country code.    countriesSupported    Text    Countries for which the application is supported. You can also provide the two-letter ISO 3166-1 alpha-2 country code.    downloadUrl    URL    If the file can be downloaded, URL to download the binary.    "
    downloadUrl: String
    "    featureList    Text  or URL    Features or modules provided by this application (and possibly required by other applications).    "
    featureList: String
    identifier: String
    "    fileSize    Text    Size of the application / package (e.g. 18MB). In the absence of a unit (MB, KB etc.), KB will be assumed.    installUrl    URL    URL at which the app may be installed, if different from the URL of the item.    "
    installUrl: String
    name: String
    namespaces: [NamespaceRef!]
    "    memoryRequirements    Text  or URL    Minimum memory requirements.    operatingSystem    Text    Operating systems supported (Windows 7, OSX 10.6, Android 1.6).    permissions    Text    Permission(s) required to run the app (for example, a mobile app may require full internet access or may run only on wifi).    processorRequirements    Text    Processor architecture required to run the application (e.g. IA64).    releaseNotes    Text  or URL    Description of what changed in this version.    "
    releaseNotes: String
    "    screenshot    ImageObject  or URL    A link to a screenshot image of the app.    "
    screenshot: String
    "    softwareAddOn    SoftwareApplication    Additional content for a software application.    softwareHelp    CreativeWork    Software application help.    softwareRequirements    Text  or URL    Component dependency requirements for application. This includes runtime environments and shared libraries that are not included in the application distribution package, but required to run the application (Examples: DirectX, Java or .NET runtime). Supersedes requirements.    softwareVersion    Text    Version of the software instance.    storageRequirements    Text  or URL    Storage requirements (free space required).    supportingData    DataFeed    Supporting data for a SoftwareApplication.    "
    softwareVersion: String
}

input SoftwareApplicationRef {
    alternateName: String
    "    applicationSuite    Text    The name of the application suite to which the application belongs (e.g. Excel belongs to Office).    "
    applicationSuite: String
    description: String
    "    availableOnDevice    Text    Device required to run the application. Used in cases where a specific make/model is required to run the application. Supersedes device.    countriesNotSupported    Text    Countries for which the application is not supported. You can also provide the two-letter ISO 3166-1 alpha-2 country code.    countriesSupported    Text    Countries for which the application is supported. You can also provide the two-letter ISO 3166-1 alpha-2 country code.    downloadUrl    URL    If the file can be downloaded, URL to download the binary.    "
    downloadUrl: String
    "    featureList    Text  or URL    Features or modules provided by this application (and possibly required by other applications).    "
    featureList: String
    id: ID
    identifier: String
    "    fileSize    Text    Size of the application / package (e.g. 18MB). In the absence of a unit (MB, KB etc.), KB will be assumed.    installUrl    URL    URL at which the app may be installed, if different from the URL of the item.    "
    installUrl: String
    name: String
    namespaces: [NamespaceRef!]
    "    memoryRequirements    Text  or URL    Minimum memory requirements.    operatingSystem    Text    Operating systems supported (Windows 7, OSX 10.6, Android 1.6).    permissions    Text    Permission(s) required to run the app (for example, a mobile app may require full internet access or may run only on wifi).    processorRequirements    Text    Processor architecture required to run the application (e.g. IA64).    releaseNotes    Text  or URL    Description of what changed in this version.    "
    releaseNotes: String
    "    screenshot    ImageObject  or URL    A link to a screenshot image of the app.    "
    screenshot: String
    "    softwareAddOn    SoftwareApplication    Additional content for a software application.    softwareHelp    CreativeWork    Software application help.    softwareRequirements    Text  or URL    Component dependency requirements for application. This includes runtime environments and shared libraries that are not included in the application distribution package, but required to run the application (Examples: DirectX, Java or .NET runtime). Supersedes requirements.    softwareVersion    Text    Version of the software instance.    storageRequirements    Text  or URL    Storage requirements (free space required).    supportingData    DataFeed    Supporting data for a SoftwareApplication.    "
    softwareVersion: String
}

input StoreFilter {
    and: StoreFilter
    id: [ID!]
    name: StringHashFilter
    not: StoreFilter
    or: StoreFilter
}

input StoreOrder {
    asc: StoreOrderable
    desc: StoreOrderable
    then: StoreOrder
}

input StorePatch {
    alternateName: String
    creator: UserRef
    "    ãåå»ºæ¥æã    "
    dateCreated: DateTime
    "    ãæ´æ°æ¥æã    "
    dateModified: DateTime
    description: String
    employees: [EmployeeRoleRef]
    followers: [FollowerRoleRef]
    hasNamespaces: [NamespaceRef!]
    hasPartyRoleName: [PartyRoleNameRef]
    identifier: String
    members: [MemberRoleRef]
    name: String
    namespaces: [NamespaceRef!]
    owns: [OwnershipRef]
}

input StoreRef {
    alternateName: String
    creator: UserRef
    "    ãåå»ºæ¥æã    "
    dateCreated: DateTime
    "    ãæ´æ°æ¥æã    "
    dateModified: DateTime
    description: String
    employees: [EmployeeRoleRef]
    followers: [FollowerRoleRef]
    hasNamespaces: [NamespaceRef!]
    hasPartyRoleName: [PartyRoleNameRef]
    id: ID
    identifier: String
    members: [MemberRoleRef]
    name: String
    namespaces: [NamespaceRef!]
    owns: [OwnershipRef]
}

input StringExactFilter {
    eq: String
    ge: String
    gt: String
    le: String
    lt: String
}

input StringExactFilter_StringRegExpFilter {
    eq: String
    ge: String
    gt: String
    le: String
    lt: String
    regexp: String
}

input StringFullTextFilter {
    alloftext: String
    anyoftext: String
}

input StringHashFilter {
    eq: String
}

input StringRegExpFilter {
    regexp: String
}

input StringTermFilter {
    allofterms: String
    anyofterms: String
}

input ThingFilter {
    and: ThingFilter
    name: StringHashFilter
    not: ThingFilter
    or: ThingFilter
}

input ThingOrder {
    asc: ThingOrderable
    desc: ThingOrderable
    then: ThingOrder
}

input ThingPatch {
    "    ãå«åã è¯¥é¡¹çå«åã An alias for the item.    "
    alternateName: String
    "ãæè¿°ã è¯¥é¡¹çä¸ä¸ªç®åæè¿°ã A description of the item."
    description: String
    "    ãæ è¯ç¬¦ã æ è¯ç¬¦ The identifier property represents any kind of identifier for any kind of Thing, such as ISBNs, GTIN codes, UUIDs etc.    "
    identifier: String
    "    ãåç§°ãname    Text    The name of the item.    "
    name: String
    namespaces: [NamespaceRef!]
}

input UpdateCartInput {
    filter: CartFilter!
    remove: CartPatch
    set: CartPatch
}

input UpdateCartItemInput {
    filter: CartItemFilter!
    remove: CartItemPatch
    set: CartItemPatch
}

input UpdateCheckoutInput {
    filter: CheckoutFilter!
    remove: CheckoutPatch
    set: CheckoutPatch
}

input UpdateCheckoutItemInput {
    filter: CheckoutItemFilter!
    remove: CheckoutItemPatch
    set: CheckoutItemPatch
}

input UpdateConversationInput {
    filter: ConversationFilter!
    remove: ConversationPatch
    set: ConversationPatch
}

input UpdateDataCatalogInput {
    filter: DataCatalogFilter!
    remove: DataCatalogPatch
    set: DataCatalogPatch
}

input UpdateEmployeeRoleInput {
    filter: EmployeeRoleFilter!
    remove: EmployeeRolePatch
    set: EmployeeRolePatch
}

input UpdateEntryPointInput {
    filter: EntryPointFilter!
    remove: EntryPointPatch
    set: EntryPointPatch
}

input UpdateFollowerRoleInput {
    filter: FollowerRoleFilter!
    remove: FollowerRolePatch
    set: FollowerRolePatch
}

input UpdateGeneralOrganizationInput {
    filter: GeneralOrganizationFilter!
    remove: GeneralOrganizationPatch
    set: GeneralOrganizationPatch
}

input UpdateMemberRoleInput {
    filter: MemberRoleFilter!
    remove: MemberRolePatch
    set: MemberRolePatch
}

input UpdateMessageInput {
    filter: MessageFilter!
    remove: MessagePatch
    set: MessagePatch
}

input UpdateNamespaceInput {
    filter: NamespaceFilter!
    remove: NamespacePatch
    set: NamespacePatch
}

input UpdateOfferInput {
    filter: OfferFilter!
    remove: OfferPatch
    set: OfferPatch
}

input UpdateOwnershipInput {
    filter: OwnershipFilter!
    remove: OwnershipPatch
    set: OwnershipPatch
}

input UpdatePartyRoleNameInput {
    filter: PartyRoleNameFilter!
    remove: PartyRoleNamePatch
    set: PartyRoleNamePatch
}

input UpdatePersonInput {
    filter: PersonFilter!
    remove: PersonPatch
    set: PersonPatch
}

input UpdatePoderInput {
    filter: PoderFilter!
    remove: PoderPatch
    set: PoderPatch
}

input UpdatePoderItemInput {
    filter: PoderItemFilter!
    remove: PoderItemPatch
    set: PoderItemPatch
}

input UpdateProductInput {
    filter: ProductFilter!
    remove: ProductPatch
    set: ProductPatch
}

input UpdateProductModelInput {
    filter: ProductModelFilter!
    remove: ProductModelPatch
    set: ProductModelPatch
}

input UpdateReadNoteInput {
    filter: ReadNoteFilter!
    remove: ReadNotePatch
    set: ReadNotePatch
}

input UpdateReviewInput {
    filter: ReviewFilter!
    remove: ReviewPatch
    set: ReviewPatch
}

input UpdateSoftwareApplicationInput {
    filter: SoftwareApplicationFilter!
    remove: SoftwareApplicationPatch
    set: SoftwareApplicationPatch
}

input UpdateStoreInput {
    filter: StoreFilter!
    remove: StorePatch
    set: StorePatch
}

input UpdateThingInput {
    filter: ThingFilter!
    remove: ThingPatch
    set: ThingPatch
}

input UpdateUserInput {
    filter: UserFilter!
    remove: UserPatch
    set: UserPatch
}

input UpdateWebhookInput {
    filter: WebhookFilter!
    remove: WebhookPatch
    set: WebhookPatch
}

input UserFilter {
    and: UserFilter
    id: [ID!]
    name: StringHashFilter
    not: UserFilter
    or: UserFilter
    username: StringHashFilter
}

input UserOrder {
    asc: UserOrderable
    desc: UserOrderable
    then: UserOrder
}

input UserPatch {
    alternateName: String
    "    The user's public profile bio.    "
    bio: String
    description: String
    identifier: String
    isUserOf: PersonRef
    name: String
    namespaces: [NamespaceRef!]
    "    The password used to login.    "
    password: String
}

input UserRef {
    alternateName: String
    "    The user's public profile bio.    "
    bio: String
    description: String
    id: ID
    identifier: String
    isUserOf: PersonRef
    name: String
    namespaces: [NamespaceRef!]
    "    The password used to login.    "
    password: String
    "    The username used to login.    We also want to make sure that usernames are unique. The @id directive takes care of that - it also automatically adds hash searching, so we can drop the @search(by: [hash]), though having it also causes no harm.    "
    username: String
}

input WebhookFilter {
    and: WebhookFilter
    id: [ID!]
    name: StringHashFilter
    not: WebhookFilter
    or: WebhookFilter
}

input WebhookOrder {
    asc: WebhookOrderable
    desc: WebhookOrderable
    then: WebhookOrder
}

input WebhookPatch {
    alternateName: String
    client: SoftwareApplicationRef
    "    åè°æäº¤çæ°æ®åå®¹ç±»åå¦application/json    "
    contentType: String
    creator: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    "    åè°url    "
    payloadUrl: String
    "    ä½¿ç¨payloadUrlçå®å¨token    "
    secret: String
}

input WebhookRef {
    alternateName: String
    client: SoftwareApplicationRef
    "    åè°æäº¤çæ°æ®åå®¹ç±»åå¦application/json    "
    contentType: String
    creator: UserRef
    "    ãåå»ºæ¥æã åä½åºCreativeWorkçæ¥æã The date on which the CreativeWork was created or the item was added to a DataFeed. dateCreated    DateTime or Date or DataFeedItem or CreativeWork    "
    dateCreated: DateTime
    description: String
    id: ID
    identifier: String
    name: String
    namespaces: [NamespaceRef!]
    "    åè°url    "
    payloadUrl: String
    "    ä½¿ç¨payloadUrlçå®å¨token    "
    secret: String
}


scalar DateTime